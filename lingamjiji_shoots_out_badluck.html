<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- é—œéµä¿®æ­£ï¼šåŠ å…¥ viewport-fit=cover ä»¥å•Ÿç”¨å®‰å…¨å€è®Šæ•¸ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>LINGAMJIJI SHOOTER</title>
    <style>
        /* ä½¿ç”¨ Tailwind æ¦‚å¿µçš„è‡ªå®šç¾©CSSè®“éŠæˆ²çœ‹èµ·ä¾†æ›´ç¾è§€ï¼Œä¸¦ç¢ºä¿ç§»å‹•ç«¯å‹å¥½ */
        html, body {
            height: 100%; /* ç¢ºä¿ HTML å’Œ Body ä½”æ»¿æ•´å€‹è¦–çª— */
            margin: 0;
            /* ğŸ¯ ç¢ºä¿å…§å®¹ä¸è¢«ç³»çµ± UI é®æ“‹ */
            overflow: hidden; 
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* é è¨­å±…ä¸­æ‰€æœ‰å…§å®¹ */
            justify-content: center; 
            min-height: 100vh;
            background-color: #2c3e50; /* æ·±è—è‰²èƒŒæ™¯ */
            font-family: 'Inter', sans-serif;
            color: #ecf0f1;
            box-sizing: border-box;
            
            /* ğŸ¯ æ ¸å¿ƒä¿®æ­£ï¼šå°‡æ‰€æœ‰é‚Šç•Œç©ºé–“å’Œå®‰å…¨å€éƒ½è¨­å®šåœ¨ body padding */
            padding-top: 5px; /* æ¨¡æ“¬åŸå…ˆ game-container çš„é ‚éƒ¨ 5px margin */
            /* 20px å›ºå®šç·©è¡ + ç³»çµ±å®‰å…¨å€ï¼Œç¢ºä¿æ¸…ç©ºç€è¦½å™¨åœ°å€æ¬„ç©ºé–“ */
            padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px)); 
        }
        
        /* éŠæˆ²ç‹€æ…‹ä¸‹çš„ body æ¨£å¼èª¿æ•´ï¼Œè®“å…§å®¹æ›´é é ‚éƒ¨ */
        body.game-active {
            justify-content: flex-start;
        }

        #game-title {
            margin: 0 0 5px 0; /* æ¥µå°çš„åº•éƒ¨é–“è· */
            text-align: center;
            width: 100%;
        }
        #game-title h1 {
            font-size: 1.8em;
            color: #f1c40f;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            margin: 0;
        }

        #game-container {
            width: 100%; /* ä½”æ»¿å¯ç”¨å¯¬åº¦ */
            max-width: 600px; /* é™åˆ¶æœ€å¤§å¯¬åº¦ */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            background-color: #34495e;
            position: relative;
            
            /* é—œéµæ”¹å‹•ï¼šç§»é™¤ marginï¼Œä½¿ç”¨ body padding æ§åˆ¶é‚Šè· */
            margin: 0; 
            
            /* é—œéµæ”¹å‹•ï¼šä½¿ç”¨ 100% height ä½”æ»¿ body å…§å‰©é¤˜ç©ºé–“ */
            display: flex;
            flex-direction: column;
            flex-grow: 1; 
            height: 85%;
            max-height: 100%; 
        }

        #gameCanvas {
            display: block;
            width: 100%;
            /* é—œéµæ”¹å‹•ï¼šä½”ç”¨æ‰€æœ‰å‚ç›´å‰©é¤˜ç©ºé–“ */
            flex-grow: 1; 
            min-height: 200px; /* ç¢ºä¿æœ€å°é«˜åº¦ */
            cursor: pointer; 
        }

        #ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 0.8em;
            background-color: #2c3e50;
            /* ç¢ºä¿ UI panel ä¸æœƒè¢«å£“ç¸® */
            flex-shrink: 0; 
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }
        
        .game-info {
            font-weight: bold;
            flex: 1;
            text-align: center;
            white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ›è¡Œ */
        }
        .game-info:first-child { text-align: left; }
        .game-info:last-child { text-align: right; }

        /* ------------------------------------- */
        /* ç”Ÿå‘½å€¼æŒ‡ç¤ºç‡ˆæ¨£å¼ */
        .life-indicators {
            display: flex;
            gap: 5px;
            justify-content: center;
        }
        .life-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #ecf0f1;
            transition: background-color 0.3s;
        }
        .life-green { background-color: #2ecc71; }
        .life-yellow { background-color: #f1c40f; }
        .life-red { background-color: #e74c3c; }
        .life-grey { background-color: #7f8c8d; }
        /* ------------------------------------- */

        /* ------------------------------------- */
        /* å……èƒ½æ¢æ¨£å¼ */
        .charge-info {
            flex: 2; /* çµ¦äºˆå……èƒ½æ¢æ›´å¤šç©ºé–“ */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .charge-bar-wrapper {
            display: inline-block;
            width: 60px;
            height: 8px;
            background-color: #7f8c8d;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
            vertical-align: middle;
            margin-left: 5px;
        }
        .charge-fill {
            height: 100%;
            width: 0%;
            background-color: #3498db;
            transition: width 0.1s;
        }
        /* ------------------------------------- */
        
        /* ------------------------------------- */
        /* Super Bomb Button Style */
        #superBombButton {
            position: absolute;
            /* æ”¾ç½®åœ¨ç•«å¸ƒçš„å³ä¸‹æ–¹ï¼Œè®“é–‹ç ²å°å’Œåº•éƒ¨ UI é¢æ¿ */
            bottom: calc(75px + 10px); /* 10px æ˜¯ UI-Panel çš„ padding-top/bottom */
            right: 15px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid #f1c40f;
            background-color: #34495e;
            color: #ecf0f1;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 5;
            opacity: 0.5;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            /* é è¨­ç‹€æ…‹ï¼šä¸å¹²æ“¾ç•«å¸ƒé»æ“Š */
            pointer-events: none; 
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
        }
        /* å……èƒ½å®Œç•¢æ™‚çš„æ¨£å¼ */
        #superBombButton.ready {
            background-color: #e74c3c; /* äº®ç´…è‰² */
            opacity: 1.0;
            transform: scale(1.1);
            pointer-events: auto; /* å•Ÿç”¨é»æ“Š */
            box-shadow: 0 0 15px #e74c3c, 0 0 5px #f1c40f;
        }
        #superBombButton:active.ready {
            transform: scale(1.0);
            box-shadow: 0 0 5px #e74c3c;
        }
        /* ------------------------------------- */

        /* éŠæˆ²é–‹å§‹/çµæŸè¨Šæ¯æ¡† (ä¿æŒä¸è®Š) */
        #messageBox {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.95);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            font-size: 1.0em;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            gap: 10px;
            transition: opacity 0.3s;
        }
        #messageBox h2 {
            font-size: 1.0em;
            margin-bottom: 5px;
        }
        #messageBox p {
            font-size: 0.8em;
            margin: 0;
        }

        /* è§’è‰²é¸æ“‡å®¹å™¨: 2x2 Grid Layout (ä¿æŒä¸è®Š) */
        #selection-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* å…©åˆ—ç­‰å¯¬ */
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
            width: 90%;
            max-width: 250px; 
        }
        
        /* è§’è‰²å¡ç‰‡æ¨£å¼ (ä¿æŒä¸è®Š) */
        .cannon-card {
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            border: 3px solid transparent;
            transition: all 0.2s;
            background-color: #34495e;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            width: 100%; 
            box-sizing: border-box;
        }
        .cannon-card:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }
        .cannon-card.selected {
            border-color: #f1c40f;
            transform: scale(1.05);
        }
        .cannon-card img {
            width: 45px;
            height: 45px;
            border-radius: 4px;
        }
        .cannon-card p {
            font-size: 0.7em;
            font-weight: bold;
            margin-top: 5px;
        }

        /* é–‹å§‹/é‡æ–°é–‹å§‹æŒ‰éˆ• (ä¿æŒä¸è®Š) */
        #startRestartButton {
            padding: 8px 15px; 
            font-size: 0.8em; 
            font-weight: bold;
            color: white;
            background-color: #e74c3c;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px #c0392b;
            transition: background-color 0.1s, box-shadow 0.1s, transform 0.1s;
        }
        #startRestartButton:active {
            box-shadow: 0 0;
            transform: translateY(4px);
        }
    </style>
</head>
<body>

    <!-- éŠæˆ²æ¨™é¡Œå…ƒç´ ï¼Œç”¨æ–¼åœ¨ééŠæˆ²ç‹€æ…‹ä¸‹é¡¯ç¤º -->
    <div id="game-title">
        <h1>LINGAMJIJI SHOOTER</h1>
    </div>

    <div id="game-container">
        <!-- ç•«å¸ƒç¾åœ¨ä¹Ÿä½œç‚ºè¼¸å…¥å€åŸŸ -->
        <canvas id="gameCanvas"></canvas>
        
        <!-- å¤§çµ•æ‹›æŒ‰éˆ•ç–ŠåŠ åœ¨ç•«å¸ƒä¸Š -->
        <button id="superBombButton" class="bomb-button">
            <span id="bombCount">B</span>
        </button>

        <div id="ui-panel">
            <!-- æ›´æ”¹æ¨™ç±¤ç‚º SCR -->
            <div class="game-info">SCR: <span id="scoreDisplay">0</span></div>
            
            <div class="game-info charge-info">
                <!-- æ›´æ”¹æ¨™ç±¤ç‚º CHG -->
                CHG: <span id="chargeBar" class="charge-bar-wrapper">
                    <div id="chargeFill" class="charge-fill"></div>
                </span>
            </div>
            
            <!-- æ›´æ”¹æ¨™ç±¤ç‚º LVL -->
            <div class="game-info">LVL: <span id="levelDisplay">1</span></div>
            <div class="game-info life-indicators-wrapper">
                <div id="livesContainer" class="life-indicators">
                    <div id="life3" class="life-dot life-green"></div>
                    <div id="life2" class="life-dot life-green"></div>
                    <div id="life1" class="life-dot life-green"></div>
                </div>
            </div>
        </div>
        
        <div id="messageBox">
            <h2 id="messageTitle"></h2>
            <div id="selection-container"></div>
            <p id="messageText"></p>
            <button id="startRestartButton" class="control-button">START GAME</button>
        </div>
    </div>
    
    <script>
        // =================================================================================
        // åœ–ç‰‡è‡ªå®šç¾©é…ç½®å€å¡Š
        // =================================================================================
        
        // ç ²å°ç¢°æ’å€åŸŸå°ºå¯¸ï¼š70x70px
        const CANNON_COLLISION_SIZE = 70;
        // éŠæˆ²å…§ç ²å°åœ–ç‰‡é¡¯ç¤ºå°ºå¯¸ï¼š70x70px
        const CANNON_DISPLAY_SIZE = 70;
        
        // åŒ…å«å¯é¸è§’è‰²å’Œéš¨æ©Ÿé¸é …
        const CANNONS_CONFIG = {
            'cannon1': {
                url: 'flyA.gif', // æ›´æ–°ç‚ºæœ¬åœ°è·¯å¾‘
                name: 'POMO',
                image: new Image(),
                type: 'selectable',
                // --- Pomo (ç©¿é€) ç‰¹æ€§ ---
                bulletRadius: 4, 
                fireRateMultiplier: 2.0, 
                bulletColor: '#3498db', 
                bulletDurability: 3, 
                description: 'SLOW RATE, HIGH PIERCING',
            },
            'cannon2': {
                url: 'flyB.gif', // æ›´æ–°ç‚ºæœ¬åœ°è·¯å¾‘
                name: 'ZHENGYUAN',
                image: new Image(),
                type: 'selectable',
                // --- Zhengyuan (éœ°å½ˆ) ç‰¹æ€§ ---
                bulletRadius: 2.5, 
                fireRateMultiplier: 1.0, 
                bulletColor: '#e74c3c', 
                description: 'STANDARD RATE, SCATTER SHOT',
            },
            'cannon3': {
                url: 'flyC.gif', // æ›´æ–°ç‚ºæœ¬åœ°è·¯å¾‘
                name: 'FENGSHENG',
                image: new Image(),
                type: 'selectable',
                // --- Fengsheng (é€£å°„) ç‰¹æ€§ ---
                bulletRadius: 4, 
                fireRateMultiplier: 0.5, 
                bulletColor: '#f1c40f', 
                description: 'RAPID FIRE, STANDARD SHOT',
            },
            'random': {
                // ä½¿ç”¨ä½”ä½ç¬¦åœ–ç‰‡æˆ–é è¨­ç¹ªè£½ï¼Œæ­¤è™•ç”¨ä½”ä½ç¬¦
                url: 'https://placehold.co/70x70/3498db/FFFFFF?text=RANDOM',
                name: 'RANDOM',
                image: new Image(),
                type: 'random',
                description: 'RANDOM CANNON SELECTED',
            }
        };

        let selectedCannonId = 'random'; // é è¨­é¸æ“‡éš¨æ©Ÿ
        let cannonImage = CANNONS_CONFIG[selectedCannonId].image; // ç•¶å‰ä½¿ç”¨çš„åœ–ç‰‡ç‰©ä»¶
        let currentCannonConfig = {}; // å­˜å„²ç•¶å‰è§’è‰²çš„é…ç½®
        const BASE_AUTO_FIRE_INTERVAL = 200; // åŸºç¤è‡ªå‹•å°„æ“Šé–“éš” (æ¯«ç§’)

        // é è¼‰å…¥æ‰€æœ‰åœ–ç‰‡
        Object.values(CANNONS_CONFIG).forEach(cannon => {
            cannon.image.onload = () => { cannon.image.isLoaded = true; };
            cannon.image.onerror = () => { console.error(`åœ–ç‰‡è¼‰å…¥å¤±æ•—: ${cannon.name}`); cannon.image.isLoaded = false; };
            cannon.image.src = cannon.url;
        });


        // =================================================================================
        // éŸ³æ•ˆé…ç½®èˆ‡é è¼‰å…¥
        // æé†’ï¼šè«‹å°‡è·¯å¾‘æ›¿æ›ç‚ºæ‚¨å¯¦éš›çš„éŸ³è¨Šæª” URL
        // =================================================================================
        
        const SFX_PATHS = {
            LASER: 'audio/Laser.mp3',             // å°„æ“Š (åŸºç¤æª”ï¼Œç”¨ä¾†è®Šé€Ÿ)
            POP: 'audio/Pop.mp3',                 // æ“Šä¸­/æ“Šæ¯€
            HIT: 'audio/Hit.mp3',                 // è§’è‰²å—å‚·
            POWER_UP: 'audio/Power-Up.mp3',       // å……èƒ½å®Œæˆ
            ULTIMATE_BOOM: 'audio/UltimateBoom.mp3'// é‡‹æ”¾å¤§çµ•
        };

        const sfx = {};
        for (const key in SFX_PATHS) {
            sfx[key] = new Audio(SFX_PATHS[key]);
            sfx[key].load();
        }

        /**
         * æ’­æ”¾éŸ³æ•ˆçš„é€šç”¨å‡½æ•¸ï¼Œç¢ºä¿å¯ä»¥é‡è¤‡æ’­æ”¾ä¸¦è¨­å®šåƒæ•¸ã€‚
         * @param {HTMLAudioElement} audio åŸå§‹éŸ³è¨Šå…ƒç´ 
         * @param {number} volume éŸ³é‡ (0.0 - 1.0)
         * @param {number} rate æ’­æ”¾é€Ÿç‡ (ä¾‹å¦‚ 1.0, 0.8, 1.2)
         */
        function playSfx(audio, volume = 1.0, rate = 1.0) {
            if (!audio) return;
            // ä½¿ç”¨ cloneNode ç¢ºä¿éŸ³æ•ˆå¯ä»¥å¿«é€Ÿä¸”é‡è¤‡æ’­æ”¾
            const clone = audio.cloneNode(true);
            clone.volume = Math.min(1.0, Math.max(0.0, volume)); 
            clone.playbackRate = rate;
            // å˜—è©¦æ’­æ”¾ï¼Œé˜²æ­¢æœªç¶“ç”¨æˆ¶äº’å‹•è¢«ç€è¦½å™¨é˜»æ­¢
            clone.play().catch(e => { /* éœé»˜è™•ç†è‡ªå‹•æ’­æ”¾å¤±æ•— */ });
        }


        // =================================================================================
        // å…¨åŸŸå¸¸æ•¸èˆ‡åˆå§‹åŒ–
        // =================================================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const startRestartButton = document.getElementById('startRestartButton');
        const selectionContainer = document.getElementById('selection-container');
        const gameTitleElement = document.getElementById('game-title'); 
        const bodyElement = document.body; 
        const lifeDots = [
            document.getElementById('life1'),
            document.getElementById('life2'),
            document.getElementById('life3')
        ];
        
        // ğŸ¯ å¤§çµ•æ‹›ç³»çµ±ç›¸é—œ DOM å…ƒç´ 
        const superBombButton = document.getElementById('superBombButton');
        const bombCountDisplay = document.getElementById('bombCount');
        const chargeFill = document.getElementById('chargeFill');

        // é»´èŒé¡è‰²é…ç½® (å·²æ›´æ–°ç‚ºå…«ç¨®ä¸åŒé¡è‰²)
        const MOLD_COLORS = {
            'normal': '#3c6e71',    // å¢¨ç¶ è‰² (åŸºç¤)
            'lively': '#fca311',    // æ©™é»ƒè‰² (æ´»æ½‘)
            'fast': '#e74c3c',      // äº®ç´…è‰² (ç–¾é€Ÿ)
            'dashing': '#5d5d5a',   // ç°é»‘è‰² (è¡åˆº)
            'armored': {            // è£ç”²é»´èŒ (å…©ç¨®é¡è‰²)
                full: '#55a630',    // æ£®æ—ç¶  (æ»¿è¡€)
                hit: '#76c893'      // æ·ºç¶  (å—æ)
            },
            'weaving': '#d5bdaf',   // ç±³é»ƒè‰² (ç·¨ç¹”)
            'sturdy': '#8e7a00',    // æ·±åœŸé»ƒè‰² (å …å›º)
            'huge': '#7a5a8f'       // ç´«ç¾…è˜­è‰² (å·¨å¤§)
        };
        const MOLD_NORMAL_RADIUS = 15;
        const MOLD_BASE_SPEED = 0.8;
        
        // éŠæˆ²ç‹€æ…‹è®Šæ•¸
        let cannon = {};
        let bullets = [];
        let mold = [];
        let score = 0;
        let lives = 3;
        let isGameOver = false;
        let isGameStarted = false;
        let gameLoopRunning = false;
        let lastMoldSpawnTime = 0;
        let moldSpawnInterval = 1000;
        let moldSpeed = MOLD_BASE_SPEED;
        
        // ğŸ¯ å¤§çµ•æ‹›ç³»çµ±ç‹€æ…‹
        let superBombCharge = 0;
        let superBombs = 0;
        const CHARGE_THRESHOLD = 1000;
        let isSuperExploding = false;
        let superExplosionStartTime = 0; // çˆ†ç‚¸é–‹å§‹æ™‚é–“
        const SUPER_EXPLOSION_DURATION = 1000; // çˆ†ç‚¸è¦–è¦ºå’Œéœ‡å‹•æŒçºŒæ™‚é–“ 1000ms
        const SUPER_SHAKE_INTENSITY = 10; // çˆ†ç‚¸éœ‡å‹•å¼·åº¦
        
        // ç©å®¶è¼¸å…¥ç‹€æ…‹
        let leftPressed = false;
        let rightPressed = false;

        // è‡ªå‹•å°„æ“Šç‹€æ…‹
        let autoFireInterval = BASE_AUTO_FIRE_INTERVAL;
        let lastFireTime = 0;
        
        // æ“Šä¸­æ•ˆæœç‹€æ…‹
        let explosions = [];

        // å‚·å®³è¦–è¦ºæ•ˆæœç‹€æ…‹
        let damageEffectActive = false;
        const DAMAGE_DURATION = 300;
        let damageStartTime = 0;
        
        // é›£åº¦æ§åˆ¶è®Šæ•¸
        let difficultyLevel = 1;
        const DIFFICULTY_STEP_SCORE = 120;
        let nextDifficultyScore = DIFFICULTY_STEP_SCORE;
        const DIFFICULTY_FACTOR = 1.1;
        
        // é»´èŒç”Ÿæˆè¼ªæ›¿é‚è¼¯ (å·²æ“´å±•è‡³ 8 ç¨®)
        let moldTypeCounter = 0;
        const MOLD_TYPES_SEQUENCE = [
            'normal', 'fast', 'lively', 'normal', 
            'armored', 'dashing', 'sturdy', 'huge', 
            'weaving', 'normal'
        ];

        // ----------------------------------------------------
        // è¼”åŠ©å‡½æ•¸: æ ¹æ“šç­‰ç´šè¨ˆç®—èƒŒæ™¯é¡è‰² (å¾æ·±è—åˆ°ç™½)
        // ----------------------------------------------------
        function getBackgroundColor(level) {
            const maxLevelForColor = 100;
            const progress = Math.min(1, (level - 1) / (maxLevelForColor - 1));
            // å¾ #2c3e50 (44, 62, 80) é€æ¼¸éæ¸¡åˆ°ç™½è‰² (255, 255, 255)
            const r = Math.floor(44 + (255 - 44) * progress);
            const g = Math.floor(62 + (255 - 62) * progress);
            const b = Math.floor(80 + (255 - 80) * progress);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // ----------------------------------------------------
        // è¼”åŠ©å‡½æ•¸: å‰µå»ºä¸åŒé¡å‹çš„é»´èŒ (åŒ…å« 4 ç¨®æ–°é¡å‹)
        // ----------------------------------------------------
        function createMold(type, baseSpeed) {
            let m = {
                x: Math.random() * (canvas.width - MOLD_NORMAL_RADIUS * 2) + MOLD_NORMAL_RADIUS,
                y: -MOLD_NORMAL_RADIUS,
                radius: MOLD_NORMAL_RADIUS,
                type: type,
                health: 1,
                ySpeed: baseSpeed,
                hSpeed: 0,
                color: MOLD_COLORS[type] || MOLD_COLORS['normal'], // ä½¿ç”¨æ–°çš„é¡è‰²é…ç½®
                dashTimer: 0,
                isDashing: false,
                dashInterval: 3000 * (1 / baseSpeed),
                normalRadius: MOLD_NORMAL_RADIUS,
                isHit: false,
                hitTimer: 0,
            };

            switch (type) {
                case 'huge':
                    m.health = 12;
                    m.maxRadius = 25;
                    m.medRadius = 20;
                    m.radius = m.maxRadius;
                    m.ySpeed = baseSpeed / 3;
                    m.x = Math.random() * (canvas.width - m.radius * 2) + m.radius;
                    m.color = MOLD_COLORS['huge'];
                    break;
                case 'lively':
                    m.hSpeed = 1.5 * (Math.random() > 0.5 ? 1 : -1);
                    m.color = MOLD_COLORS['lively'];
                    break;
                case 'dashing':
                    m.dashTimer = m.dashInterval + Math.random() * 1500;
                    m.color = MOLD_COLORS['dashing'];
                    break;
                case 'fast': // ç–¾é€Ÿé»´èŒ (25åˆ†)
                    m.ySpeed = baseSpeed * 2.0;
                    m.color = MOLD_COLORS['fast'];
                    break;
                case 'armored': // è£ç”²é»´èŒ (30åˆ†)
                    m.health = 2;
                    m.armoredColor = MOLD_COLORS['armored'].full; // æ£®æ—ç¶  (æ»¿è¡€)
                    m.unarmoredColor = MOLD_COLORS['armored'].hit; // æ·ºç¶  (å—æ)
                    m.color = m.armoredColor;
                    break;
                case 'weaving': // ç·¨ç¹”é»´èŒ (35åˆ†)
                    m.hSpeed = 1.0 * (Math.random() > 0.5 ? 1 : -1);
                    m.weaveTimer = 1000; // æ¯ 1000ms æ”¹è®Šä¸€æ¬¡æ–¹å‘
                    m.color = MOLD_COLORS['weaving'];
                    break;
                case 'sturdy': // å …å›ºé»´èŒ (40åˆ†)
                    m.health = 6;
                    m.ySpeed = baseSpeed * 0.5;
                    m.color = MOLD_COLORS['sturdy'];
                    break;
                case 'normal':
                default:
                    m.color = MOLD_COLORS['normal'];
                    break;
            }
            return m;
        }
        
        // ç¢ºä¿ç•«å¸ƒå°ºå¯¸é©æ‡‰å®¹å™¨
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            
            // ğŸ¯ ç²å–ç”± CSS è¨­ç½®çš„å®¢æˆ¶ç«¯å°ºå¯¸
            const clientWidth = container.clientWidth;
            const canvasElement = document.getElementById('gameCanvas');
            const clientHeight = canvasElement.clientHeight;

            // è¨­ç½®ç•«å¸ƒçš„ç¹ªåœ–å°ºå¯¸
            canvasElement.width = clientWidth;
            canvasElement.height = clientHeight;

            // èª¿æ•´ç ²å°ä½ç½®
            if (cannon.x !== undefined) {
                cannon.x = Math.max(0, Math.min(cannon.x, canvasElement.width - cannon.width));
                cannon.y = canvasElement.height - CANNON_COLLISION_SIZE - 10;
            } else {
                cannon.width = CANNON_COLLISION_SIZE;
                cannon.height = CANNON_COLLISION_SIZE;
                cannon.imgWidth = CANNON_DISPLAY_SIZE;
                cannon.imgHeight = CANNON_DISPLAY_SIZE;
                cannon.x = canvasElement.width / 2 - (CANNON_COLLISION_SIZE / 2);
                cannon.y = canvasElement.height - CANNON_COLLISION_SIZE - 10;
                cannon.speed = 6;
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // ----------------------------------------------------
        // ä»‹é¢æ›´æ–°
        // ----------------------------------------------------

        function updateLivesDisplay() {
            playSfx(sfx.HIT, 0.8, 1.0); // æ’­æ”¾å—å‚·éŸ³æ•ˆ

            lifeDots.forEach((dot, index) => {
                dot.className = 'life-dot'; // é‡ç½®æ¨£å¼
                if (index < lives) {
                    // æ ¹æ“šç”Ÿå‘½å€¼è¨­ç½®é¡è‰²
                    if (lives === 3) dot.classList.add('life-green');
                    else if (lives === 2) dot.classList.add('life-yellow');
                    else dot.classList.add('life-red');
                } else {
                    dot.classList.add('life-grey'); // å¤±å»çš„ç”Ÿå‘½å€¼é¡¯ç¤ºç°è‰²
                }
            });
        }
        
        function updateChargeDisplay() {
            const ratio = superBombs === 0 ? superBombCharge / CHARGE_THRESHOLD : 1; // å……æ»¿æ™‚é¡¯ç¤º 100%
            chargeFill.style.width = `${ratio * 100}%`;

            if (superBombs > 0) {
                superBombButton.classList.add('ready');
                bombCountDisplay.textContent = 'B'; 
            } else {
                superBombButton.classList.remove('ready');
                bombCountDisplay.textContent = '0';
            }
        }
        
        function updateScore(points) {
            const previousSuperBombs = superBombs;
            
            score += points;
            scoreDisplay.textContent = score;

            // ğŸ¯ çºŒèƒ½é‚è¼¯ï¼šåªæœ‰ç•¶å‰æ²’æœ‰å¤§ç‚¸å½ˆæ™‚æ‰ç´¯ç©é»æ•¸
            if (superBombs < 1) {
                superBombCharge += points;
                if (superBombCharge >= CHARGE_THRESHOLD) {
                    superBombs = 1;
                    superBombCharge = CHARGE_THRESHOLD; // å……æ»¿å¾Œé–å®šåœ¨é–€æª»å€¼
                }
            }
            
            // æ’­æ”¾å……èƒ½å®ŒæˆéŸ³æ•ˆ
            if (superBombs > previousSuperBombs) {
                 playSfx(sfx.POWER_UP, 1.0, 1.0); 
            }
            
            updateChargeDisplay();

            // æª¢æŸ¥æ˜¯å¦å‡ç´š
            if (score >= nextDifficultyScore) {
                difficultyLevel++;
                levelDisplay.textContent = difficultyLevel;
                // åŠ é€Ÿé»´èŒç”Ÿæˆå’Œç§»å‹•é€Ÿåº¦
                moldSpawnInterval = Math.max(200, moldSpawnInterval * 0.9); // æœ€å°é–“éš” 200ms
                moldSpeed = MOLD_BASE_SPEED * Math.pow(DIFFICULTY_FACTOR, difficultyLevel - 1);
                
                // èª¿æ•´ä¸‹ä¸€ç´šæ‰€éœ€åˆ†æ•¸
                nextDifficultyScore = Math.ceil(nextDifficultyScore * 1.5);
            }
        }

        // ----------------------------------------------------
        // éŠæˆ²æµç¨‹æ§åˆ¶
        // ----------------------------------------------------
        
        function selectRandomCannon() {
            const selectableIds = Object.keys(CANNONS_CONFIG).filter(id => CANNONS_CONFIG[id].type === 'selectable');
            const randomId = selectableIds[Math.floor(Math.random() * selectableIds.length)];
            return randomId;
        }

        function startGame() {
            // 1. è™•ç†éš¨æ©Ÿé¸æ“‡
            let finalCannonId = selectedCannonId;
            if (finalCannonId === 'random') {
                finalCannonId = selectRandomCannon();
            }
            
            // 2. æ‡‰ç”¨è§’è‰²é…ç½®
            currentCannonConfig = CANNONS_CONFIG[finalCannonId];
            cannonImage = currentCannonConfig.image;
            if (!cannonImage.isLoaded) {
                 console.warn(`Warning: Cannon image for ${currentCannonConfig.name} is not loaded.`);
            }

            autoFireInterval = BASE_AUTO_FIRE_INTERVAL * currentCannonConfig.fireRateMultiplier;
            
            // 3. å˜—è©¦æ’­æ”¾ä¸€æ¬¡è²éŸ³ä»¥è§£é–ç€è¦½å™¨éŸ³è¨Š
            playSfx(sfx.LASER, 0.0);
            
            // 4. åˆå§‹åŒ–éŠæˆ²ç‹€æ…‹
            initGame();
            
            isGameStarted = true;
            messageBox.style.display = 'none';

            // éš±è—æ¨™é¡Œï¼Œå°‡ body é ‚éƒ¨å°é½Šï¼Œæœ€å¤§åŒ–éŠæˆ²ç•«å¸ƒç©ºé–“
            gameTitleElement.style.display = 'none';
            bodyElement.classList.add('game-active');
            
            // é‡æ–°èª¿æ•´å°ºå¯¸ä»¥é©æ‡‰æ¨™é¡Œéš±è—å¾Œçš„ç©ºé–“è®ŠåŒ–
            resizeCanvas();

            if (!gameLoopRunning) {
                gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function showGameOver(title, message) {
            isGameOver = true;
            gameLoopRunning = false;
            
            messageTitle.textContent = title;
            messageText.innerHTML = `${message}<br>${score} MOLD PURIFIED!`; // Final Score message adjusted
            selectionContainer.innerHTML = ''; // æ¸…é™¤é¸æ“‡ä»‹é¢
            startRestartButton.textContent = 'RESTART'; // Restart button
            messageBox.style.display = 'flex';
            
            // é¡¯ç¤ºæ¨™é¡Œï¼Œå°‡ body å…§å®¹å±…ä¸­
            gameTitleElement.style.display = 'block';
            bodyElement.classList.remove('game-active');
        }
        
        // ----------------------------------------------------
        // å¤§çµ•æ‹›é‚è¼¯
        // ----------------------------------------------------

        function fireSuperBomb() {
            if (superBombs < 1 || isGameOver) return;
            
            playSfx(sfx.ULTIMATE_BOOM, 1.0, 1.0); // æ’­æ”¾å¤§çµ•éŸ³æ•ˆ

            // 1. æ¸…ç©ºæ‰€æœ‰é»´èŒå’Œå­å½ˆ
            const moldsCleared = mold.length;
            mold = [];
            bullets = [];
            
            // 2. æ‡‰ç”¨åˆ†æ•¸çå‹µ
            // æ¯å€‹æ¸…é™¤çš„é»´èŒçµ¦äºˆ 20 é¡å¤–åˆ†æ•¸
            const bonusScore = moldsCleared * 20; 
            updateScore(bonusScore); 

            // 3. è§¸ç™¼è¶…å¤§çˆ†ç‚¸è¦–è¦ºå’Œéœ‡å‹•æ•ˆæœ
            isSuperExploding = true;
            superExplosionStartTime = performance.now(); // è¨˜éŒ„é–‹å§‹æ™‚é–“
            
            // 4. é‡ç½®ç‹€æ…‹
            superBombs = 0;
            superBombCharge = 0;
            updateChargeDisplay();
        }

        // ----------------------------------------------------
        // éŠæˆ²è¼¸å…¥è™•ç†
        // ----------------------------------------------------

        function handleInput() {
            if (isGameStarted && !isGameOver) {
                const step = cannon.speed;
                if (leftPressed) {
                    cannon.x = Math.max(0, cannon.x - step);
                }
                if (rightPressed) {
                    cannon.x = Math.min(canvas.width - cannon.width, cannon.x + step);
                }
            }
        }
        
        function handleCanvasControl(e) {
            if (messageBox.style.display !== 'none' || !isGameStarted || isGameOver) return;
            
            let clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
            if (e.touches) e.preventDefault(); // é˜»æ­¢ç§»å‹•ç«¯é è¨­è¡Œç‚º
            
            const rect = canvas.getBoundingClientRect();
            const touchX = clientX - rect.left; 
            
            if (touchX < canvas.width / 2) {
                leftPressed = true;
                rightPressed = false;
            } else {
                rightPressed = true;
                leftPressed = false;
            }
        }
        
        function stopMovement() {
            leftPressed = false;
            rightPressed = false;
        }

        // è¨»å†Šç•«å¸ƒäº‹ä»¶ç›£è½å™¨
        canvas.addEventListener('mousedown', handleCanvasControl);
        canvas.addEventListener('touchstart', handleCanvasControl, { passive: false }); 
        canvas.addEventListener('mouseup', stopMovement);
        canvas.addEventListener('touchend', stopMovement);
        canvas.addEventListener('mouseleave', stopMovement); 
        
        // è¨»å†Šå¤§çµ•æ‹›æŒ‰éˆ•äº‹ä»¶
        superBombButton.addEventListener('click', fireSuperBomb);
        
        // éµç›¤äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = true;
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = true;
            } else if ((e.key === ' ' || e.key === 'Enter') && superBombs > 0) {
                fireSuperBomb();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = false;
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = false;
            }
        });

        // é–‹å§‹/é‡æ–°é–‹å§‹æŒ‰éˆ•äº‹ä»¶
        startRestartButton.addEventListener('click', () => {
            if (isGameStarted && isGameOver) {
                initGame();
                showCharacterSelection();
            } else if (!isGameStarted) {
                startGame();
            }
        });

        // ----------------------------------------------------
        // å°„æ“Šã€æ›´æ–°ã€ç¢°æ’é‚è¼¯ 
        // ----------------------------------------------------
        
        function getCannonShotRate(cannonName) {
            if (cannonName === 'POMO') return 0.8; 
            if (cannonName === 'FENGSHENG') return 1.2;
            return 1.0; 
        }

        function fireBullet() {
            const { bulletRadius, bulletColor, bulletDurability, name } = currentCannonConfig;
            
            // æ’­æ”¾å°„æ“ŠéŸ³æ•ˆï¼Œä¸¦æ ¹æ“šæ©Ÿé«”é¡å‹èª¿æ•´æ’­æ”¾é€Ÿç‡
            playSfx(sfx.LASER, 0.5, getCannonShotRate(name));

            if (name === 'POMO') {
                bullets.push({
                    x: cannon.x + cannon.width / 2,
                    y: cannon.y,
                    radius: bulletRadius,
                    color: bulletColor,
                    durability: bulletDurability,
                    type: 'pomo', 
                    hSpeed: 0
                });
            } else if (name === 'ZHENGYUAN') {
                for (let i = -1; i <= 1; i++) {
                    bullets.push({
                        x: cannon.x + cannon.width / 2 + i * 5, 
                        y: cannon.y,
                        radius: bulletRadius,
                        color: bulletColor,
                        durability: 1, 
                        type: 'zhengyuan',
                        hSpeed: i * 0.5
                    });
                }
            } else {
                 bullets.push({
                    x: cannon.x + cannon.width / 2,
                    y: cannon.y,
                    radius: bulletRadius,
                    color: bulletColor,
                    durability: 1,
                    type: 'normal',
                    hSpeed: 0
                });
            }
        }

        function updateGame(deltaTime) {
            const now = performance.now();

            handleInput();

            if (now - lastFireTime > autoFireInterval) {
                fireBullet();
                lastFireTime = now;
            }

            bullets = bullets.filter(bullet => {
                bullet.y -= 8;
                bullet.x += bullet.hSpeed || 0;
                return bullet.y + bullet.radius > 0;
            });

            updateMolds(deltaTime, now);
            
            if (now - lastMoldSpawnTime > moldSpawnInterval) {
                const type = MOLD_TYPES_SEQUENCE[moldTypeCounter % MOLD_TYPES_SEQUENCE.length];
                mold.push(createMold(type, moldSpeed));
                moldTypeCounter++;
                lastMoldSpawnTime = now;
            }
            
            checkCollisions(deltaTime);
            updateExplosions(deltaTime);

            if (lives <= 0) {
                // English Game Over messages
                showGameOver('ENERGY DEPLETED', 'CONGRATULATIONS, YOU HAVE PURIFIED');
            }
        }
        
        function updateMolds(deltaTime, now) {
            mold = mold.filter(m => {
                m.y += m.ySpeed;

                if (m.type === 'lively') {
                    m.x += m.hSpeed;
                    if (m.x - m.radius < 0 || m.x + m.radius > canvas.width) m.hSpeed *= -1;
                } else if (m.type === 'weaving') {
                    if (now - m.weaveTimer > 1000) {
                        m.hSpeed *= -1;
                        m.weaveTimer = now;
                    }
                    m.x += m.hSpeed;
                    if (m.x - m.radius < 0) { m.x = m.radius; m.hSpeed = Math.abs(m.hSpeed); }
                    if (m.x + m.radius > canvas.width) { m.x = canvas.width - m.radius; m.hSpeed = -Math.abs(m.hSpeed); }
                } else if (m.type === 'dashing') {
                    m.dashTimer -= deltaTime;
                    if (m.dashTimer < 0 && !m.isDashing) {
                        m.isDashing = true;
                        m.dashTimer = 500; 
                    }
                    if (m.isDashing) {
                        m.y += m.ySpeed * 5; 
                        m.dashTimer -= deltaTime;
                        if (m.dashTimer <= 0) {
                            m.isDashing = false;
                            m.dashTimer = m.dashInterval + Math.random() * 1500;
                        }
                    }
                }

                if (m.isHit) {
                    m.hitTimer -= deltaTime;
                    if (m.hitTimer <= 0) m.isHit = false;
                }

                if (m.y - m.radius > canvas.height) return false; 

                // ç¢°æ’æª¢æ¸¬ - è§’è‰²
                if (
                    m.y + m.radius >= cannon.y && m.y - m.radius <= cannon.y + cannon.height &&
                    m.x + m.radius >= cannon.x && m.x - m.radius <= cannon.x + cannon.width
                ) {
                    lives--;
                    updateLivesDisplay();
                    triggerDamageEffect(now);
                    createExplosion(m.x, m.y, m.radius, m.color);
                    return false; 
                }

                return true;
            });
        }
        
        function checkCollisions(deltaTime) {
            const nextBullets = [];
            const moldsToKeep = [];

            mold.forEach(m => {
                let moldHitThisFrame = false; // ç”¨æ–¼é¿å…é‡è¤‡æ’­æ”¾æ“Šä¸­éŸ³æ•ˆ

                bullets.forEach(b => {
                    const dx = b.x - m.x;
                    const dy = b.y - m.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < b.radius + m.radius) {
                        
                        let damage = (b.type === 'pomo' && m.type === 'huge') ? 3 : 1;
                        const healthBeforeHit = m.health;
                        
                        m.health -= damage;
                        m.isHit = true;
                        m.hitTimer = 100;
                        moldHitThisFrame = true; // æ¨™è¨˜è¢«æ“Šä¸­

                        if (m.type === 'armored' && m.health === 1) m.color = m.unarmoredColor;

                        if (m.type === 'huge') {
                            if (m.health <= 4 && m.radius > m.normalRadius) m.radius = m.normalRadius;
                            else if (m.health <= 8 && m.radius > m.medRadius) m.radius = m.medRadius;
                        }
                        
                        if (m.health <= 0) {
                            // æ“Šæ¯€éŸ³æ•ˆ (Pop.mp3, æ­£å¸¸æ’­æ”¾)
                            playSfx(sfx.POP, 0.7, 1.0); 
                            
                            let points = 10;
                            switch (m.type) {
                                case 'fast': points = 25; break;
                                case 'armored': points = 30; break;
                                case 'weaving': points = 35; break;
                                case 'sturdy': points = 40; break;
                                case 'huge': points = 50; break;
                                case 'lively': points = 20; break;
                                case 'dashing': points = 30; break;
                                default: points = 10; break;
                            }
                            updateScore(points);
                            createExplosion(m.x, m.y, m.radius, m.color);
                        } else if (healthBeforeHit > 0) {
                            // æ“Šä¸­éŸ³æ•ˆ (Pop.mp3, å¿«é€Ÿé«˜éŸ³)
                            playSfx(sfx.POP, 0.3, 1.5); 
                        }

                        b.durability--;
                    }
                });

                if (m.health > 0) moldsToKeep.push(m);
            });
            
            bullets.forEach(b => {
                if (b.durability > 0) nextBullets.push(b);
            });

            mold = moldsToKeep;
            bullets = nextBullets;
        }

        // ----------------------------------------------------
        // è¦–è¦ºç‰¹æ•ˆè™•ç†
        // ----------------------------------------------------
        
        function createExplosion(x, y, radius, color) {
            explosions.push({
                x: x,
                y: y,
                radius: radius,
                color: color,
                maxRadius: radius * 3,
                alpha: 1.0,
                speed: 10
            });
        }

        function updateExplosions(deltaTime) {
            explosions = explosions.filter(exp => {
                exp.radius += exp.speed * (deltaTime / 16.67);
                exp.alpha -= 0.05 * (deltaTime / 16.67);
                return exp.alpha > 0;
            });
        }
        
        function triggerDamageEffect(now) {
            damageEffectActive = true;
            damageStartTime = now;
        }

        function getShakeOffset(now) {
            let shakeOffset = 0;
            
            // 1. å‚·å®³éœ‡å‹•
            if (damageEffectActive) {
                const elapsed = now - damageStartTime;
                if (elapsed < DAMAGE_DURATION) {
                    shakeOffset = 5 * (1 - elapsed / DAMAGE_DURATION);
                } else {
                    damageEffectActive = false;
                }
            }
            
            // 2. çˆ†ç‚¸éœ‡å‹• (è¦†è“‹å‚·å®³éœ‡å‹•)
            if (isSuperExploding) {
                const elapsed = now - superExplosionStartTime;
                if (elapsed < SUPER_EXPLOSION_DURATION) {
                    const progress = elapsed / SUPER_EXPLOSION_DURATION;
                    // å¾æœ€å¤§å¼·åº¦éæ¸›
                    shakeOffset = SUPER_SHAKE_INTENSITY * (1 - progress); 
                } else {
                    isSuperExploding = false; // éœ‡å‹•çµæŸ
                }
            }

            return shakeOffset;
        }
        
        // ----------------------------------------------------
        // ç¹ªåœ–é‚è¼¯
        // ----------------------------------------------------

        function drawGame() {
            if (!gameLoopRunning && !isGameStarted) return;
            
            const now = performance.now();

            ctx.fillStyle = getBackgroundColor(difficultyLevel);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ‡‰ç”¨ç•«é¢éœ‡å‹•æ•ˆæœ
            const currentShakeOffset = getShakeOffset(now);
            const dx = currentShakeOffset > 0 ? Math.sin(now * 0.5) * currentShakeOffset : 0;
            const dy = currentShakeOffset > 0 ? Math.cos(now * 0.5) * currentShakeOffset : 0;
            ctx.save();
            ctx.translate(dx, dy);

            // 1. ç¹ªè£½é»´èŒ
            mold.forEach(m => {
                if (m.isHit && Math.floor(m.hitTimer / 50) % 2 === 0) {
                    ctx.fillStyle = '#ecf0f1';
                } else {
                    ctx.fillStyle = m.color;
                }
                
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();
                
                if (m.type === 'dashing' && !m.isDashing && m.dashTimer < 1000 && m.dashTimer > 0) {
                    const alpha = (1000 - m.dashTimer) / 1000 * 0.5;
                    ctx.fillStyle = `rgba(231, 76, 60, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, m.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                const maxHealth = (m.type === 'huge' ? 12 : (m.type === 'sturdy' ? 6 : (m.type === 'armored' ? 2 : 1)));
                if (maxHealth > 1) {
                    const healthRatio = m.health / maxHealth;
                    const barWidth = m.radius * 2;
                    const barHeight = 4;
                    const barX = m.x - m.radius;
                    const barY = m.y - m.radius - 8;
                    
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = healthRatio > 0.5 ? '#2ecc71' : (healthRatio > 0.25 ? '#f1c40f' : '#e74c3c');
                    ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
                }
            });

            // 2. ç¹ªè£½å­å½ˆ
            bullets.forEach(b => {
                if (b.type === 'pomo') {
                    const durabilityRatio = b.durability / currentCannonConfig.bulletDurability;
                    ctx.fillStyle = `rgba(52, 152, 219, ${0.4 + durabilityRatio * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = '8px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(b.durability, b.x, b.y);
                } else {
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // 3. ç¹ªè£½çˆ†ç‚¸æ•ˆæœ
            explosions.forEach(exp => {
                ctx.fillStyle = exp.color;
                ctx.globalAlpha = exp.alpha;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });

            // 4. ç¹ªè£½ç ²å° (åœ–ç‰‡)
            if (cannonImage.isLoaded) {
                ctx.drawImage(
                    cannonImage,
                    cannon.x,
                    cannon.y,
                    cannon.imgWidth,
                    cannon.imgHeight
                );
            } else {
                ctx.fillStyle = 'red';
                ctx.fillRect(cannon.x, cannon.y, cannon.width, cannon.height);
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(currentCannonConfig.name, cannon.x + cannon.width / 2, cannon.y + cannon.height / 2);
            }
            
            // æ¢å¾©ç•«å¸ƒç‹€æ…‹
            ctx.restore();
            
            // 5. ç¹ªè£½è¶…ç´šçˆ†ç‚¸æ•ˆæœ
            if (isSuperExploding) {
                const elapsed = now - superExplosionStartTime;
                const progress = elapsed / SUPER_EXPLOSION_DURATION;
                
                let radius = canvas.width * 0.8 * progress; 
                let alpha = 1.0 - progress;

                ctx.globalAlpha = Math.max(0, alpha * 0.9);
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // ----------------------------------------------------
        // éŠæˆ²ä¸»å¾ªç’°
        // ----------------------------------------------------
        let lastTime = 0;

        function gameLoop(currentTime) {
            if (!gameLoopRunning) return;

            const deltaTime = Math.min(currentTime - lastTime, 100); 
            lastTime = currentTime;
            
            if (!isGameOver) {
                updateGame(deltaTime);
            }
            drawGame();

            requestAnimationFrame(gameLoop);
        }

        // ----------------------------------------------------
        // å•Ÿå‹•é»
        // ----------------------------------------------------

        // ç¢ºä¿åœ¨æ‰€æœ‰ DOM å…ƒç´ è¼‰å…¥å¾Œé¡¯ç¤ºé¸æ“‡ç•«é¢
        window.onload = function() {
            resizeCanvas(); 
            initGame();
            showCharacterSelection();
        };

        // ----------------------------------------------------
        // è§’è‰²é¸æ“‡èˆ‡ç•«é¢é¡¯ç¤º (ä½¿ç”¨è‹±æ–‡)
        // ----------------------------------------------------

        function showCharacterSelection() {
            selectionContainer.innerHTML = '';
            messageTitle.textContent = 'SELECT YOUR CANNON'; // English Title
            startRestartButton.textContent = 'START GAME'; // English Button
            messageText.textContent = CANNONS_CONFIG[selectedCannonId].description || '';

            Object.keys(CANNONS_CONFIG).forEach(id => {
                const cannon = CANNONS_CONFIG[id];
                const card = document.createElement('div');
                card.id = `card-${id}`;
                card.className = 'cannon-card';
                
                const img = document.createElement('img');
                img.src = cannon.url;
                img.width = CANNON_COLLISION_SIZE;
                img.height = CANNON_COLLISION_SIZE;

                const nameLabel = document.createElement('p');
                nameLabel.textContent = cannon.name;

                card.appendChild(img);
                card.appendChild(nameLabel);
                selectionContainer.appendChild(card);

                card.addEventListener('click', () => selectCannon(id));
            });
            
            selectCannon(selectedCannonId);
            messageBox.style.display = 'flex';
        }

        function selectCannon(id) {
            selectedCannonId = id;
            document.querySelectorAll('.cannon-card').forEach(card => {
                card.classList.remove('selected');
                if (card.id === `card-${id}`) {
                    card.classList.add('selected');
                }
            });
            const selectedConfig = CANNONS_CONFIG[id];
            messageText.textContent = selectedConfig.description;
        }

        function initGame() {
            score = 0;
            lives = 3;
            isGameOver = false;
            isGameStarted = false;
            bullets = [];
            mold = [];
            explosions = [];
            
            difficultyLevel = 1;
            nextDifficultyScore = DIFFICULTY_STEP_SCORE;
            moldSpeed = MOLD_BASE_SPEED;
            moldSpawnInterval = 1000;
            
            superBombCharge = 0;
            superBombs = 0;
            isSuperExploding = false;

            gameTitleElement.style.display = 'block';
            bodyElement.classList.remove('game-active');

            resizeCanvas();

            cannon.width = CANNON_COLLISION_SIZE;
            cannon.height = CANNON_COLLISION_SIZE;
            cannon.imgWidth = CANNON_DISPLAY_SIZE;
            cannon.imgHeight = CANNON_DISPLAY_SIZE;
            cannon.x = canvas.width / 2 - (CANNON_COLLISION_SIZE / 2);
            cannon.y = canvas.height - CANNON_COLLISION_SIZE - 10;
            cannon.speed = 6;
            
            scoreDisplay.textContent = score;
            levelDisplay.textContent = difficultyLevel;

            updateLivesDisplay();
            updateChargeDisplay();
            
            requestAnimationFrame(drawGame);
        }
    </script>
</body>
</html>


