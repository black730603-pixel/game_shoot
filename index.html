<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>éˆæ ¹å‰å‰å°„çˆ†éœ‰é‹</title>
    <!-- å¼•å…¥ html2canvas åº«ï¼Œç”¨æ–¼å°‡ HTML å…ƒç´ è½‰æ›ç‚ºåœ–ç‰‡ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* ä½¿ç”¨ Tailwind æ¦‚å¿µçš„è‡ªå®šç¾©CSSè®“éŠæˆ²çœ‹èµ·ä¾†æ›´ç¾è§€ï¼Œä¸¦ç¢ºä¿ç§»å‹•ç«¯å‹å¥½ */
        html, body {
            height: 100%; /* ç¢ºä¿ HTML å’Œ Body ä½”æ»¿æ•´å€‹è¦–çª— */
            margin: 0;
            /* ğŸ¯ ç¢ºä¿å…§å®¹ä¸è¢«ç³»çµ± UI é®æ“‹ */
            overflow: hidden; 
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* é è¨­å±…ä¸­æ‰€æœ‰å…§å®¹ */
            justify-content: center; 
            min-height: 100vh;
            background-color: #2c3e50; /* æ·±è—è‰²èƒŒæ™¯ */
            font-family: 'Inter', sans-serif;
            color: #ecf0f1;
            box-sizing: border-box;
            
            /* ğŸ¯ æ ¸å¿ƒä¿®æ­£ï¼šå°‡æ‰€æœ‰é‚Šç•Œç©ºé–“å’Œå®‰å…¨å€éƒ½è¨­å®šåœ¨ body padding */
            padding-top: 5px; /* æ¨¡æ“¬åŸå…ˆ game-container çš„é ‚éƒ¨ 5px margin */
            /* èª¿æ•´ padding-bottom ä»¥ç¢ºä¿ footer æœ‰ç©ºé–“ï¼Œä¸¦è€ƒæ…®ç³»çµ±å®‰å…¨å€ */
            padding-bottom: env(safe-area-inset-bottom, 0px); 
        }
        
        /* éŠæˆ²ç‹€æ…‹ä¸‹çš„ body æ¨£å¼èª¿æ•´ï¼Œè®“å…§å®¹æ›´é é ‚éƒ¨ */
        body.game-active {
            justify-content: flex-start;
        }

        #game-title {
            margin: 0 0 5px 0; /* æ¥µå°çš„åº•éƒ¨é–“è· */
            text-align: center;
            width: 100%;
        }
        #game-title h1 {
            font-size: 1.8em;
            color: #f1c40f;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            margin: 0;
        }

        #game-container {
            width: 100%; /* ä½”æ»¿å¯ç”¨å¯¬åº¦ */
            max-width: 720px; /* é™åˆ¶æœ€å¤§å¯¬åº¦ */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            background-color: #34495e;
            position: relative;
            
            /* é—œéµæ”¹å‹•ï¼šç§»é™¤ marginï¼Œä½¿ç”¨ body padding æ§åˆ¶é‚Šè· */
            margin: 0; 
            
            /* é—œéµæ”¹å‹•ï¼šä½¿ç”¨ 100% height ä½”æ»¿ body å…§å‰©é¤˜ç©ºé–“ */
            display: flex;
            flex-direction: column;
            flex-grow: 1; 
            height: 100%;
            max-height: 90%; 
        }

        #gameCanvas {
            display: block;
            width: 100%;
            /* é—œéµæ”¹å‹•ï¼šä½”ç”¨æ‰€æœ‰å‚ç›´å‰©é¤˜ç©ºé–“ */
            flex-grow: 1; 
            min-height: 200px; /* ç¢ºä¿æœ€å°é«˜åº¦ */
            cursor: pointer; 
        }

        #ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 0.8em;
            background-color: #2c3e50;
            /* ç¢ºä¿ UI panel ä¸æœƒè¢«å£“ç¸® */
            flex-shrink: 0; 
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }
        
        .game-info {
            font-weight: bold;
            flex: 1;
            text-align: center;
            white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ›è¡Œ */
        }
        .game-info:first-child { text-align: left; }
        .game-info:last-child { text-align: right; }

        /* ------------------------------------- */
        /* ç”Ÿå‘½å€¼æŒ‡ç¤ºç‡ˆæ¨£å¼ */
        .life-indicators {
            display: flex;
            gap: 5px;
            justify-content: center;
        }
        .life-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #ecf0f1;
            transition: background-color 0.3s;
        }
        .life-green { background-color: #2ecc71; }
        .life-yellow { background-color: #f1c40f; }
        .life-red { background-color: #e74c3c; }
        .life-grey { background-color: #7f8c8d; }
        /* ------------------------------------- */

        /* ------------------------------------- */
        /* å……èƒ½æ¢æ¨£å¼ */
        .charge-info {
            flex: 2; /* çµ¦äºˆå……èƒ½æ¢æ›´å¤šç©ºé–“ */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .charge-bar-wrapper {
            display: inline-block;
            width: 60px;
            height: 8px;
            background-color: #7f8c8d;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
            vertical-align: middle;
            margin-left: 5px;
        }
        .charge-fill {
            height: 100%;
            width: 0%;
            background-color: #3498db;
            transition: width 0.1s;
        }
        /* ------------------------------------- */
        
        /* ------------------------------------- */
        /* Super Bomb Button Style */
        #superBombButton {
            position: absolute;
            /* æ”¾ç½®åœ¨ç•«å¸ƒçš„å³ä¸‹æ–¹ï¼Œè®“é–‹ç ²å°å’Œåº•éƒ¨ UI é¢æ¿ */
            bottom: calc(75px + 10px); /* 10px æ˜¯ UI-Panel çš„ padding-top/bottom */
            right: 15px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid #f1c40f;
            background-color: #34495e;
            color: #ecf0f1;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 5;
            opacity: 0.5;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            /* é è¨­ç‹€æ…‹ï¼šä¸å¹²æ“¾ç•«å¸ƒé»æ“Š */
            pointer-events: none; 
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
        }
        /* å……èƒ½å®Œç•¢æ™‚çš„æ¨£å¼ */
        #superBombButton.ready {
            background-color: #e74c3c; /* äº®ç´…è‰² */
            opacity: 1.0;
            transform: scale(1.1);
            pointer-events: auto; /* å•Ÿç”¨é»æ“Š */
            box-shadow: 0 0 15px #e74c3c, 0 0 5px #f1c40f;
        }
        #superBombButton:active.ready {
            transform: scale(1.0);
            box-shadow: 0 0 5px #e74c3c;
        }
        /* ------------------------------------- */

        /* éŠæˆ²é–‹å§‹/çµæŸè¨Šæ¯æ¡† (ä¿æŒä¸è®Š) */
        #messageBox {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.95);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            font-size: 1.0em;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            gap: 10px;
            transition: opacity 0.3s;
        }
        #messageBox h2 {
            font-size: 1.0em;
            margin-bottom: 5px;
        }
        #messageBox p {
            font-size: 0.8em;
            margin: 0;
        }
        
        /* é¡å¤–ç‚ºéŠæˆ²çµæŸç•«é¢æ·»åŠ æˆ°ç¸¾å¡æŒ‰éˆ•æ¨£å¼ */
        .control-button {
            padding: 8px 15px; 
            font-size: 0.8em; 
            font-weight: bold;
            color: white;
            background-color: #e74c3c;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px #c0392b;
            transition: background-color 0.1s, box-shadow 0.1s, transform 0.1s;
            margin-top: 5px;
        }
        .control-button.secondary {
             background-color: #3498db;
             box-shadow: 0 4px #2980b9;
        }
        .control-button:active {
            box-shadow: 0 0;
            transform: translateY(4px);
        }

        /* è§’è‰²é¸æ“‡å®¹å™¨: 2x2 Grid Layout (ä¿æŒä¸è®Š) */
        #selection-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* å…©åˆ—ç­‰å¯¬ */
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
            width: 90%;
            max-width: 250px; 
        }
        
        /* è§’è‰²å¡ç‰‡æ¨£å¼ (ä¿æŒä¸è®Š) */
        .cannon-card {
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            border: 3px solid transparent;
            transition: all 0.2s;
            background-color: #34495e;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            width: 100%; 
            box-sizing: border-box;
        }
        .cannon-card:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }
        .cannon-card.selected {
            border-color: #f1c40f;
            transform: scale(1.05);
        }
        .cannon-card img {
            width: 45px;
            height: 45px;
            border-radius: 4px;
        }
        .cannon-card p {
            font-size: 0.7em;
            font-weight: bold;
            margin-top: 5px;
        }
        
        /* ------------------------------------- */
        /* åº•éƒ¨ç‰ˆæ¬Šè³‡è¨Šæ¨£å¼ */
        /* ------------------------------------- */
        #game-footer {
            flex-shrink: 0; /* ç¢ºä¿ä¸è¢«å£“ç¸® */
            width: 100%;
            max-width: 600px;
            text-align: center;
            font-size: 0.7em;
            color: #7f8c8d; /* æ·ºç°è‰²æ–‡å­— */
            padding: 10px 0 5px 0; /* é ‚éƒ¨é–“è·å’Œåº•éƒ¨å¾®å°ç©ºé–“ */
            user-select: none;
        }
        
        /* ------------------------------------- */
        /* ğŸ¯ æˆ°ç¸¾å¡æ¨¡æ¿æ¨£å¼ (ç”¨æ–¼ç”Ÿæˆåœ–ç‰‡ï¼Œå¿…é ˆæ˜¯çµ•å°å°ºå¯¸ï¼Œå»ºè­°ä½¿ç”¨ px) */
        /* ------------------------------------- */
        #scoreCardTemplate {
            position: absolute; /* ä¸ä½”ç”¨ç©ºé–“ */
            left: -9999px; /* ç§»å‡ºè¦–çª—å¤– */
            top: 0;
            width: 400px; /* å›ºå®šå¯¬åº¦ï¼Œé©åˆ PNG è¼¸å‡º */
            height: 600px; /* å›ºå®šé«˜åº¦ */
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); /* æ¼¸è®ŠèƒŒæ™¯ */
            color: #ecf0f1;
            font-family: 'Inter', sans-serif;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            text-align: center;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            z-index: -100;
        }
        
        #scoreCardTemplate .title {
            font-size: 1.8em;
            color: #f1c40f;
            font-weight: 900;
            text-shadow: 0 0 5px rgba(241, 196, 15, 0.8);
            margin-bottom: 10px;
        }
        
        #scoreCardTemplate #finalScore {
            font-size: 6em; /* è¶…å¤§å­—é«”åˆ†æ•¸ */
            font-weight: bold;
            color: #2ecc71; /* ç¶ è‰²åˆ†æ•¸ */
            text-shadow: 0 0 10px rgba(46, 204, 113, 0.7);
            line-height: 1;
            margin: 10px 0;
        }
        
        #scoreCardTemplate #cannonImage {
            width: 100px;
            height: 100px;
            border: 5px solid #bdc3c7;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 10px;
        }
        
        #scoreCardTemplate .details {
            font-size: 1.2em;
            font-weight: 600;
            margin: 5px 0;
            color: #3498db;
        }
        
        #scoreCardTemplate .slogan {
            font-size: 1.5em;
            font-weight: 700;
            color: #e74c3c; /* ç´…è‰²å£è™Ÿ */
            margin: 15px 0;
        }
        
        #scoreCardTemplate .qr-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 15px;
        }
        
        #scoreCardTemplate .qr-container p {
            font-size: 0.7em;
            color: #95a5a6;
            margin: 0;
        }
    </style>
</head>
<body>

    <div id="game-title">
        <h1>éˆæ ¹å‰å‰å°„çˆ†éœ‰é‹</h1>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- ğŸ¯ æ–°å¢ GIF é¡¯ç¤ºå…ƒç´  -->
        <!-- è«‹å°‡ src æ›¿æ›ç‚ºæ‚¨æƒ³è¦æ’­æ”¾çš„ GIF åœ–ç‰‡ç¶²å€ -->
        <img id="ultimateGif" 
             src="SHIVA.gif" 
             alt="Ultimate Explosion GIF" 
             style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 9; display: none; pointer-events: none;"
             onerror="this.src='https://placehold.co/800x600/000000/FFFFFF?text=Ultimate+GIF+Missing'"
        />
        <!-- ----------------------- -->

        <button id="superBombButton" class="bomb-button">
            <span id="bombCount">B</span>
        </button>

        <div id="ui-panel">
            <div class="game-info">SCR: <span id="scoreDisplay">0</span></div>
            
            <div class="game-info charge-info">
                <span id="chargeBar" class="charge-bar-wrapper">
                    <div id="chargeFill" class="charge-fill"></div>
                </span>
            </div>
            
            <div class="game-info">
                <!-- é¡¯ç¤ºé›£åº¦ç­‰ç´šå’Œç•¶å‰ç‚®å°æ•¸é‡ -->
                LV: <span id="levelDisplay">1</span> (x<span id="cannonCountDisplay">1</span>)
            </div>
            <div class="game-info life-indicators-wrapper">
                <div id="livesContainer" class="life-indicators">
                    <div id="life3" class="life-dot life-green"></div>
                    <div id="life2" class="life-dot life-green"></div>
                    <div id="life1" class="life-dot life-green"></div>
                </div>
            </div>
        </div>
        
        <div id="messageBox">
            <h2 id="messageTitle"></h2>
            <div id="selection-container"></div>
            <p id="messageText"></p>
            <!-- æˆ°ç¸¾å¡ä¸‹è¼‰æŒ‰éˆ•å°‡æœƒè¢«æ’å…¥åœ¨é€™è£¡ -->
            <button id="startRestartButton" class="control-button">å‡ºç™¼</button>
        </div>
    </div>
    
    <footer id="game-footer">
        éˆæ ¹å‰å‰é–‹é‹å¥½ç‰©è£½è²©æ‰€ 2025å¹´å‡ºå“
    </footer>

    <!-- ğŸ¯ æˆ°ç¸¾å¡åœ–ç‰‡æ¨¡æ¿ - éš±è—åœ¨ç•«é¢ä¹‹å¤–ï¼Œç”¨æ–¼ html2canvas è™•ç† -->
    <div id="scoreCardTemplate">
        <div class="content-wrapper" style="flex-grow: 1; display: flex; flex-direction: column; align-items: center;">
            <p style="font-size: 0.8em; color: #95a5a6; margin: 0;">â€” æˆ°ç¸¾å ±å‘Š â€”</p>
            <h2 class="title">ã€Šéˆæ ¹å‰å‰å°„çˆ†éœ‰é‹ã€‹</h2>

            <img id="scoreCardCannonImage" src="" alt="æˆ°æ©Ÿåœ–å½¢" style="margin-top: 15px;" onerror="this.src='https://placehold.co/100x100/3498db/FFFFFF?text=Cannon+Image'" />
            
            <!-- ä¿®æ­£ 1ï¼šæˆ°æ©Ÿ -> ä½¿ç”¨ -->
            <p class="details" id="scoreCardCannonName">ä½¿ç”¨ï¼šXXéˆæ ¹</p> 
            <!-- ä¿®æ­£ 2ï¼šç­‰ç´šï¼šLV.1 -> ç­‰ç´šï¼š1 -->
            <p class="details" id="scoreCardLevel">ç­‰ç´šï¼š1</p>
            <!-- ä¿®æ­£ 3ï¼šç«åŠ›ç¨±è™Ÿï¼Œå°‡åœ¨ JS ä¸­å‹•æ…‹è¨­å®š -->
            <p class="details" id="scoreCardCannonCount" style="font-size: 1em;">ä½ æ˜¯éˆæ ¹å‰å‰æŒ‘æˆ°è€…ï¼</p>
            
            <div style="width: 100%; border-top: 2px dashed #95a5a6; margin: 15px 0;"></div>
            
            <!-- ä¿®æ­£ 4ï¼šæœ€çµ‚æˆ°ç¸¾ -> æ¶ˆæ»…éœ‰é‹ -->
            <p style="font-size: 1.5em; font-weight: 300; margin: 0;">æ¶ˆæ»…éœ‰é‹</p>
            <div id="finalScore">0</div>
        </div>
    </div>

    <script>
        // =================================================================================
        // åœ–ç‰‡è‡ªå®šç¾©é…ç½®å€å¡Š
        // =================================================================================
        
        // ç ²å°ç¢°æ’å€åŸŸå°ºå¯¸ï¼š70x70px
        const CANNON_COLLISION_SIZE = 70;
        // éŠæˆ²å…§ç ²å°åœ–ç‰‡é¡¯ç¤ºå°ºå¯¸ï¼š70x70px
        const CANNON_DISPLAY_SIZE = 70;
        
        // åŒ…å«å¯é¸è§’è‰²å’Œéš¨æ©Ÿé¸é …
        const CANNONS_CONFIG = {
            'cannon1': {
                url: 'flyA.gif', // æ›´æ–°ç‚ºæœ¬åœ°è·¯å¾‘
                name: 'ç ´é­”éˆæ ¹', // æ›´æ–°åç¨±ä»¥ç¬¦åˆæˆ°ç¸¾è¡¨æ ¼å¼
                image: new Image(),
                type: 'selectable',
                // --- Pomo (ç©¿é€) ç‰¹æ€§ ---
                bulletRadius: 9, 
                fireRateMultiplier: 2.0, 
                bulletColor: '#3498db', 
                bulletDurability: 9, 
                description: 'æ…¢é€Ÿé‡ç ²',
            },
            'cannon2': {
                url: 'flyB.gif', // æ›´æ–°ç‚ºæœ¬åœ°è·¯å¾‘
                name: 'æ­£ç·£éˆæ ¹', // æ›´æ–°åç¨±ä»¥ç¬¦åˆæˆ°ç¸¾è¡¨æ ¼å¼
                image: new Image(),
                type: 'selectable',
                // --- Zhengyuan (éœ°å½ˆ) ç‰¹æ€§ ---
                bulletRadius: 2, 
                fireRateMultiplier: 1.0, 
                bulletColor: '#e74c3c', 
                bulletDurability: 1, 
                description: 'ä¸­é€Ÿéœ°å½ˆ',
            },
            'cannon3': {
                url: 'flyC.gif', // æ›´æ–°ç‚ºæœ¬åœ°è·¯å¾‘
                name: 'è±ç››éˆæ ¹', // æ›´æ–°åç¨±ä»¥ç¬¦åˆæˆ°ç¸¾è¡¨æ ¼å¼
                image: new Image(),
                type: 'selectable',
                // --- Fengsheng (é€£å°„) ç‰¹æ€§ ---
                bulletRadius: 4, 
                fireRateMultiplier: 0.5, 
                bulletColor: '#f1c40f', 
                bulletDurability: 1,
                description: 'å¿«é€Ÿæ™®å½ˆ',
            },
            'random': {
                // ä½¿ç”¨ä½”ä½ç¬¦åœ–ç‰‡æˆ–é è¨­ç¹ªè£½ï¼Œæ­¤è™•ç”¨ä½”ä½ç¬¦
                url: 'https://placehold.co/70x70/3498db/FFFFFF?text=RANDOM',
                name: 'éš¨æ©Ÿéˆæ ¹',
                image: new Image(),
                type: 'random',
                description: 'æ¿•å©†æ±ºå®š',
            }
        };

        let selectedCannonId = 'random'; // é è¨­é¸æ“‡éš¨æ©Ÿ
        let cannonImage = CANNONS_CONFIG[selectedCannonId].image; // ç•¶å‰ä½¿ç”¨çš„åœ–ç‰‡ç‰©ä»¶
        let currentCannonConfig = {}; // å­˜å„²ç•¶å‰è§’è‰²çš„é…ç½®
        const BASE_AUTO_FIRE_INTERVAL = 200; // åŸºç¤è‡ªå‹•å°„æ“Šé–“éš” (æ¯«ç§’)
        
        // é è¼‰å…¥æ‰€æœ‰åœ–ç‰‡
        Object.values(CANNONS_CONFIG).forEach(cannon => {
            cannon.image.onload = () => { cannon.image.isLoaded = true; };
            cannon.image.onerror = () => { console.error(`åœ–ç‰‡è¼‰å…¥å¤±æ•—: ${cannon.name}`); cannon.image.isLoaded = false; };
            cannon.image.src = cannon.url;
        });


        // =================================================================================
        // éŸ³æ•ˆé…ç½®èˆ‡é è¼‰å…¥
        // =================================================================================
        
        const SFX_PATHS = {
            LASER: 'audio/Laser.mp3', // å°„æ“Š (åŸºç¤æª”ï¼Œç”¨ä¾†è®Šé€Ÿ)
            POP: 'audio/Pop.mp3', // æ“Šä¸­/æ“Šæ¯€
            HIT: 'audio/Hit.mp3', // è§’è‰²å—å‚·
            POWER_UP: 'audio/Power-Up.mp3', // å……èƒ½å®Œæˆ
            ULTIMATE_BOOM: 'audio/UltimateBoom.mp3'// é‡‹æ”¾å¤§çµ•
        };

        const sfx = {};
        for (const key in SFX_PATHS) {
            sfx[key] = new Audio(SFX_PATHS[key]);
            sfx[key].load();
        }

        /**
         * æ’­æ”¾éŸ³æ•ˆçš„é€šç”¨å‡½æ•¸ï¼Œç¢ºä¿å¯ä»¥é‡è¤‡æ’­æ”¾ä¸¦è¨­å®šåƒæ•¸ã€‚
         */
        function playSfx(audio, volume = 1.0, rate = 1.0) {
            if (!audio) return;
            // ä½¿ç”¨ cloneNode ç¢ºä¿éŸ³æ•ˆå¯ä»¥å¿«é€Ÿä¸”é‡è¤‡æ’­æ”¾
            const clone = audio.cloneNode(true);
            clone.volume = Math.min(1.0, Math.max(0.0, volume)); 
            clone.playbackRate = rate;
            // å˜—è©¦æ’­æ”¾ï¼Œé˜²æ­¢æœªç¶“ç”¨æˆ¶äº’å‹•è¢«ç€è¦½å™¨é˜»æ­¢
            clone.play().catch(e => { /* éœé»˜è™•ç†è‡ªå‹•æ’­æ”¾å¤±æ•— */ });
        }


        // =================================================================================
        // å…¨åŸŸå¸¸æ•¸èˆ‡åˆå§‹åŒ–
        // =================================================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const startRestartButton = document.getElementById('startRestartButton');
        const selectionContainer = document.getElementById('selection-container');
        const gameTitleElement = document.getElementById('game-title'); 
        const bodyElement = document.body; 
        const cannonCountDisplay = document.getElementById('cannonCountDisplay');
        const lifeDots = [
            document.getElementById('life1'),
            document.getElementById('life2'),
            document.getElementById('life3')
        ];
        
        // ğŸ¯ å¤§çµ•æ‹›ç³»çµ±ç›¸é—œ DOM å…ƒç´ 
        const superBombButton = document.getElementById('superBombButton');
        const bombCountDisplay = document.getElementById('bombCount');
        const chargeFill = document.getElementById('chargeFill');
        
        // ğŸ¯ æˆ°ç¸¾å¡ç›¸é—œ DOM å…ƒç´ 
        const scoreCardTemplate = document.getElementById('scoreCardTemplate');

        // ğŸ¯ æ–°å¢ GIF å…ƒç´ ç²å–
        const ultimateGif = document.getElementById('ultimateGif'); 
        
        // ğŸ¯ æ–°å¢ï¼šç‚®å°å‡ç´šç›¸é—œè®Šæ•¸ (å·²æ›´æ–°ç‚ºä¸Šé™ 3 å€‹)
        const CANNON_UPGRADE_THRESHOLD_1 = 10000;
        const CANNON_UPGRADE_THRESHOLD_2 = 20000;
        const MAX_CANNON_COUNT = 3; 

        let nextCannonThreshold = CANNON_UPGRADE_THRESHOLD_1; 
        let cannonCount = 1; // ç©å®¶æ“æœ‰çš„ç‚®å°æ•¸é‡
        const CANNON_SPACING = CANNON_DISPLAY_SIZE + 10; // ç‚®å°ä¹‹é–“çš„é–“è·
        
        // ğŸ¯ é›£åº¦éš¨åˆ†æ•¸å¢åŠ ï¼ˆæ–°çš„é‚è¼¯ï¼‰
        const SCORE_TIER_THRESHOLD = 10000;
        const DIFFICULTY_HP_MULTIPLIER = 1.3;
        const DIFFICULTY_SCORE_MULTIPLIER = 1.3;

        let scoreTier = 0; // 0: 0-9999, 1: 10000-19999, 2: 20000-29999, etc.
        let nextScoreTierThreshold = SCORE_TIER_THRESHOLD; // 10000
        let currentHealthFactor = 1.0; // Health multiplier based on scoreTier
        let currentScoreFactor = 1.0; // Score multiplier based on scoreTier

        // é»´èŒé¡è‰²é…ç½® (å·²æ›´æ–°ç‚ºå…«ç¨®ä¸åŒé¡è‰²)
        const MOLD_COLORS = {
            'normal': '#3c6e71', // å¢¨ç¶ è‰² (åŸºç¤)
            'lively': '#fca311', // æ©™é»ƒè‰² (æ´»æ½‘)
            'fast': '#e74c3c', // äº®ç´…è‰² (ç–¾é€Ÿ)
            'dashing': '#5d5d5a', // ç°é»‘è‰² (è¡åˆº)
            'armored': { // è£ç”²é»´èŒ (å…©ç¨®é¡è‰²)
                full: '#55a630', // æ£®æ—ç¶  (æ»¿è¡€)
                hit: '#76c893' // æ·ºç¶  (å—æ)
            },
            'weaving': '#d5bdaf', // ç±³é»ƒè‰² (ç·¨ç¹”)
            'sturdy': '#8e7a00', // æ·±åœŸé»ƒè‰² (å …å›º)
            'huge': '#7a5a8f' // ç´«ç¾…è˜­è‰² (å·¨å¤§)
        };
        const MOLD_NORMAL_RADIUS = 15;
        const MOLD_BASE_SPEED = 0.8;
        
        // éŠæˆ²ç‹€æ…‹è®Šæ•¸
        let cannon = {}; // ç‚®å°ç¾åœ¨ä»£è¡¨æ•´å€‹ç·¨éšŠçš„ä¸­å¿ƒé»
        let bullets = [];
        let mold = [];
        let score = 0;
        let lives = 3;
        let isGameOver = false;
        let isGameStarted = false;
        let gameLoopRunning = false;
        let lastMoldSpawnTime = 0;
        let moldSpawnInterval = 1000;
        let moldSpeed = MOLD_BASE_SPEED;
        
        // ğŸ¯ å¤§çµ•æ‹›ç³»çµ±ç‹€æ…‹
        let superBombCharge = 0;
        let superBombs = 0;
        const CHARGE_THRESHOLD = 1000;
        let isSuperExploding = false;
        let superExplosionStartTime = 0; // çˆ†ç‚¸é–‹å§‹æ™‚é–“
        const SUPER_EXPLOSION_DURATION = 1000; // çˆ†ç‚¸è¦–è¦ºå’Œéœ‡å‹•æŒçºŒæ™‚é–“ 1000ms
        const SUPER_SHAKE_INTENSITY = 10; // çˆ†ç‚¸éœ‡å‹•å¼·åº¦
        
        // ç©å®¶è¼¸å…¥ç‹€æ…‹
        let leftPressed = false;
        let rightPressed = false;

        // è‡ªå‹•å°„æ“Šç‹€æ…‹
        let autoFireInterval = BASE_AUTO_FIRE_INTERVAL;
        let lastFireTime = 0;
        
        // æ“Šä¸­æ•ˆæœç‹€æ…‹
        let explosions = [];

        // å‚·å®³è¦–è¦ºæ•ˆæœç‹€æ…‹
        let damageEffectActive = false;
        const DAMAGE_DURATION = 300;
        let damageStartTime = 0;
        
        // é›£åº¦æ§åˆ¶è®Šæ•¸
        let difficultyLevel = 1;
        const DIFFICULTY_STEP_SCORE = 120;
        let nextDifficultyScore = DIFFICULTY_STEP_SCORE;
        const DIFFICULTY_FACTOR = 1.1;
        
        // é»´èŒç”Ÿæˆè¼ªæ›¿é‚è¼¯ (å·²æ“´å±•è‡³ 8 ç¨®)
        let moldTypeCounter = 0;
        const MOLD_TYPES_SEQUENCE = [
            'normal', 'fast', 'lively', 'normal', 
            'armored', 'dashing', 'sturdy', 'huge', 
            'weaving', 'normal'
        ];

        // ----------------------------------------------------
        // è¼”åŠ©å‡½æ•¸: ç²å–ç‚®å°ä½ç½®è³‡è¨Š
        // ----------------------------------------------------
        /**
         * æ ¹æ“šç•¶å‰ç‚®å°æ•¸é‡å’Œç·¨éšŠä¸­å¿ƒé» (cannon.x) è¨ˆç®—æ¯å€‹ç‚®å°çš„ç¹ªåœ–å’Œä¸­å¿ƒä½ç½®ã€‚
         * @returns {Array<{drawX: number, centerX: number}>} æ¯å€‹ç‚®å°çš„ä½ç½®é™£åˆ—ã€‚
         */
        function getCannonPositions() {
            const positions = [];
            const num = cannonCount;
            
            // è¨ˆç®—ç¸½é–“è· (ä¸­å¿ƒé»åˆ°ä¸­å¿ƒé»çš„è·é›¢)
            const totalSpacing = (num - 1) * CANNON_SPACING;
            
            // å·¦å´ç¬¬ä¸€å€‹ç‚®å°çš„ä¸­å¿ƒ X åº§æ¨™
            const startCenterX = cannon.x - totalSpacing / 2;
            
            for (let i = 0; i < num; i++) {
                const individualCenterX = startCenterX + i * CANNON_SPACING;
                // ç¹ªåœ– X åº§æ¨™æ˜¯å·¦ä¸Šè§’ (ä¸­å¿ƒ X - åœ–ç‰‡åŠå¯¬)
                const individualDrawX = individualCenterX - cannon.imgWidth / 2;
                positions.push({
                    drawX: individualDrawX,
                    centerX: individualCenterX
                });
            }
            return positions;
        }

        // ----------------------------------------------------
        // è¼”åŠ©å‡½æ•¸: æ ¹æ“šç­‰ç´šè¨ˆç®—èƒŒæ™¯é¡è‰² (å¾æ·±è—åˆ°ç™½)
        // ----------------------------------------------------
        function getBackgroundColor(level) {
            const maxLevelForColor = 100;
            const progress = Math.min(1, (level - 1) / (maxLevelForColor - 1));
            // å¾ #2c3e50 (44, 62, 80) é€æ¼¸éæ¸¡åˆ°ç™½è‰² (255, 255, 255)
            const r = Math.floor(44 + (255 - 44) * progress);
            const g = Math.floor(62 + (255 - 62) * progress);
            const b = Math.floor(80 + (255 - 80) * progress);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // ----------------------------------------------------
        // è¼”åŠ©å‡½æ•¸: å‰µå»ºä¸åŒé¡å‹çš„é»´èŒ (åŒ…å« 4 ç¨®æ–°é¡å‹)
        // ----------------------------------------------------
        function createMold(type, baseSpeed) {
            let baseHealth = 1;

            let m = {
                x: Math.random() * (canvas.width - MOLD_NORMAL_RADIUS * 2) + MOLD_NORMAL_RADIUS,
                y: -MOLD_NORMAL_RADIUS,
                radius: MOLD_NORMAL_RADIUS,
                type: type,
                health: 1, 
                ySpeed: baseSpeed,
                hSpeed: 0,
                color: MOLD_COLORS[type] || MOLD_COLORS['normal'], 
                dashTimer: 0,
                isDashing: false,
                dashInterval: 3000 * (1 / baseSpeed),
                normalRadius: MOLD_NORMAL_RADIUS,
                isHit: false,
                hitTimer: 0,
            };

            // 1. æ ¹æ“šé¡å‹è¨­å®šåŸºç¤å±¬æ€§å’Œé¡è‰²
            switch (type) {
                case 'huge':
                    baseHealth = 12;
                    m.maxRadius = 25;
                    m.medRadius = 20;
                    m.radius = m.maxRadius;
                    m.ySpeed = baseSpeed / 3;
                    m.color = MOLD_COLORS['huge'];
                    break;
                case 'lively':
                    m.hSpeed = 1.5 * (Math.random() > 0.5 ? 1 : -1);
                    m.color = MOLD_COLORS['lively'];
                    break;
                case 'dashing':
                    m.dashTimer = m.dashInterval + Math.random() * 1500;
                    m.color = MOLD_COLORS['dashing'];
                    break;
                case 'fast': 
                    m.ySpeed = baseSpeed * 2.0;
                    m.color = MOLD_COLORS['fast'];
                    break;
                case 'armored': 
                    baseHealth = 2;
                    m.armoredColor = MOLD_COLORS['armored'].full; 
                    m.unarmoredColor = MOLD_COLORS['armored'].hit; 
                    m.color = m.armoredColor;
                    break;
                case 'weaving': 
                    m.hSpeed = 1.0 * (Math.random() > 0.5 ? 1 : -1);
                    m.weaveTimer = 1000;
                    m.color = MOLD_COLORS['weaving'];
                    break;
                case 'sturdy': 
                    baseHealth = 6;
                    m.ySpeed = baseSpeed * 0.5;
                    m.color = MOLD_COLORS['sturdy'];
                    break;
                case 'normal':
                default:
                    m.color = MOLD_COLORS['normal'];
                    break;
            }

            // 2. ğŸ¯ æ‡‰ç”¨é›£åº¦åˆ†æ•¸ç­‰ç´šçš„ç”Ÿå‘½å€¼ä¹˜æ•¸ï¼Œä¸¦å››æ¨äº”å…¥
            m.health = Math.round(baseHealth * currentHealthFactor);
            // ç¢ºä¿æœ€ä½ç”Ÿå‘½å€¼ç‚º 1
            if (m.health < 1) m.health = 1; 
            m.initialHealth = m.health; // ç´€éŒ„åˆå§‹è¡€é‡ä»¥ä¾¿è¨ˆç®—è¡€æ¢

            // 3. èª¿æ•´ Armored é¡å‹ï¼Œä»¥æ‡‰ç”¨æ–°çš„ health å€¼
            if (m.type === 'armored') {
                // è£ç”²é¡è‰²åœ¨è¡€é‡å¤§æ–¼ 50% æ™‚é¡¯ç¤ºï¼Œå¦å‰‡é¡¯ç¤ºå—æé¡è‰²
                m.armoredThreshold = Math.ceil(m.health / 2); 
            }

            return m;
        }
        
        // ç¢ºä¿ç•«å¸ƒå°ºå¯¸é©æ‡‰å®¹å™¨
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            
            // ğŸ¯ ç²å–ç”± CSS è¨­ç½®çš„å®¢æˆ¶ç«¯å°ºå¯¸
            const clientWidth = container.clientWidth;
            const canvasElement = document.getElementById('gameCanvas');
            const clientHeight = canvasElement.clientHeight;

            // è¨­ç½®ç•«å¸ƒçš„ç¹ªåœ–å°ºå¯¸
            canvasElement.width = clientWidth;
            canvasElement.height = clientHeight;

            // èª¿æ•´ç ²å°ä½ç½®
            // ğŸ¯ é€™è£¡å°‡ cannon.x å®šç¾©ç‚ºç‚®å°ç·¨éšŠçš„ä¸­å¿ƒ X åº§æ¨™
            if (cannon.x === undefined) {
                cannon.width = CANNON_COLLISION_SIZE;
                cannon.height = CANNON_COLLISION_SIZE;
                cannon.imgWidth = CANNON_DISPLAY_SIZE;
                cannon.imgHeight = CANNON_DISPLAY_SIZE;
                cannon.x = canvasElement.width / 2; // ä¸­å¿ƒ X åº§æ¨™
                cannon.y = canvasElement.height - CANNON_COLLISION_SIZE - 10;
                cannon.speed = 6;
            } else {
                // é‡æ–°è¨ˆç®—ä¸­å¿ƒé»ï¼Œä¸¦å°‡å…¶é™åˆ¶åœ¨é‚Šç•Œå…§
                const spacing = CANNON_SPACING;
                const formationWidth = (cannonCount - 1) * spacing + cannon.imgWidth;
                const halfFormationWidth = formationWidth / 2;

                cannon.x = Math.max(halfFormationWidth, Math.min(canvasElement.width - halfFormationWidth, cannon.x));
                cannon.y = canvasElement.height - CANNON_COLLISION_SIZE - 10;
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // ----------------------------------------------------
        // ä»‹é¢æ›´æ–°
        // ----------------------------------------------------

        function updateLivesDisplay() {
            playSfx(sfx.HIT, 0.8, 1.0); // æ’­æ”¾å—å‚·éŸ³æ•ˆ

            lifeDots.forEach((dot, index) => {
                dot.className = 'life-dot'; // é‡ç½®æ¨£å¼
                if (index < lives) {
                    // æ ¹æ“šç”Ÿå‘½å€¼è¨­ç½®é¡è‰²
                    if (lives === 3) dot.classList.add('life-green');
                    else if (lives === 2) dot.classList.add('life-yellow');
                    else dot.classList.add('life-red');
                } else {
                    dot.classList.add('life-grey'); // å¤±å»çš„ç”Ÿå‘½å€¼é¡¯ç¤ºç°è‰²
                }
            });
        }
        
        function updateChargeDisplay() {
            const ratio = superBombs === 0 ? superBombCharge / CHARGE_THRESHOLD : 1; // å……æ»¿æ™‚é¡¯ç¤º 100%
            chargeFill.style.width = `${ratio * 100}%`;

            if (superBombs > 0) {
                superBombButton.classList.add('ready');
                bombCountDisplay.textContent = 'B'; 
            } else {
                superBombButton.classList.remove('ready');
                bombCountDisplay.textContent = '0';
            }
        }
        
        function updateScore(points) {
            const previousSuperBombs = superBombs;
            
            score += points;
            scoreDisplay.textContent = score;

            // ğŸ¯ ç‚®å°å‡ç´šæª¢æŸ¥ (é™åˆ¶ç‚º 3 å€‹)
            if (cannonCount < MAX_CANNON_COUNT) {
                if (cannonCount === 1 && score >= CANNON_UPGRADE_THRESHOLD_1) {
                    cannonCount++;
                    nextCannonThreshold = CANNON_UPGRADE_THRESHOLD_2; // ä¸‹ä¸€å€‹é–¾å€¼åˆ° 20000
                    playSfx(sfx.POWER_UP, 1.0, 1.0);
                    cannonCountDisplay.textContent = cannonCount;
                    console.log(`æ­å–œï¼éˆæ ¹å‡ç´šï¼ç›®å‰æ“æœ‰ ${cannonCount} å€‹ç‚®å°ï¼`);
                    resizeCanvas();
                } else if (cannonCount === 2 && score >= CANNON_UPGRADE_THRESHOLD_2) {
                    cannonCount++;
                    nextCannonThreshold = Infinity; // é”åˆ°ä¸Šé™ï¼Œä¸å†å‡ç´š
                    playSfx(sfx.POWER_UP, 1.0, 1.0);
                    cannonCountDisplay.textContent = cannonCount;
                    console.log(`æ­å–œï¼éˆæ ¹å‡ç´šï¼ç›®å‰æ“æœ‰ ${cannonCount} å€‹ç‚®å°ï¼`);
                    resizeCanvas();
                }
            }
            
            // ğŸ¯ é›£åº¦åˆ†æ•¸ç­‰ç´šæª¢æŸ¥ (æ¯ 10000 åˆ†ï¼Œå¢åŠ  HP/åˆ†æ•¸)
            while (score >= nextScoreTierThreshold) {
                scoreTier++;
                nextScoreTierThreshold += SCORE_TIER_THRESHOLD;
                
                // å¢åŠ ç”Ÿå‘½å€¼å’Œåˆ†æ•¸ä¹˜æ•¸
                currentHealthFactor = Math.pow(DIFFICULTY_HP_MULTIPLIER, scoreTier);
                currentScoreFactor = Math.pow(DIFFICULTY_SCORE_MULTIPLIER, scoreTier);
                console.log(`åˆ†æ•¸ç­‰ç´šæå‡åˆ° ${scoreTier}ã€‚HPå€ç‡: ${currentHealthFactor.toFixed(2)}, åˆ†æ•¸å€ç‡: ${currentScoreFactor.toFixed(2)}`);
            }

            // ğŸ¯ çºŒèƒ½é‚è¼¯ï¼šåªæœ‰ç•¶å‰æ²’æœ‰å¤§ç‚¸å½ˆæ™‚æ‰ç´¯ç©é»æ•¸
            if (superBombs < 1) {
                superBombCharge += points;
                if (superBombCharge >= CHARGE_THRESHOLD) {
                    superBombs = 1;
                    superBombCharge = CHARGE_THRESHOLD; // å……æ»¿å¾Œé–å®šåœ¨é–€æª»å€¼
                }
            }
            
            // æ’­æ”¾å……èƒ½å®ŒæˆéŸ³æ•ˆ
            if (superBombs > previousSuperBombs) {
                 playSfx(sfx.POWER_UP, 1.0, 1.0); 
            }
            
            updateChargeDisplay();

            // æª¢æŸ¥æ˜¯å¦å‡ç´š (é›£åº¦ç­‰ç´š - æ§åˆ¶é»´èŒé€Ÿåº¦/ç”Ÿæˆé »ç‡)
            if (score >= nextDifficultyScore) {
                difficultyLevel++;
                levelDisplay.textContent = difficultyLevel;
                // åŠ é€Ÿé»´èŒç”Ÿæˆå’Œç§»å‹•é€Ÿåº¦
                moldSpawnInterval = Math.max(200, moldSpawnInterval * 0.9); // æœ€å°é–“éš” 200ms
                moldSpeed = MOLD_BASE_SPEED * Math.pow(DIFFICULTY_FACTOR, difficultyLevel - 1);
                
                // èª¿æ•´ä¸‹ä¸€ç´šæ‰€éœ€åˆ†æ•¸
                nextDifficultyScore = Math.ceil(nextDifficultyScore * 1.5);
            }
        }

        // ----------------------------------------------------
        // éŠæˆ²æµç¨‹æ§åˆ¶
        // ----------------------------------------------------
        
        function selectRandomCannon() {
            const selectableIds = Object.keys(CANNONS_CONFIG).filter(id => CANNONS_CONFIG[id].type === 'selectable');
            const randomId = selectableIds[Math.floor(Math.random() * selectableIds.length)];
            return randomId;
        }

        function startGame() {
            // 1. è™•ç†éš¨æ©Ÿé¸æ“‡
            let finalCannonId = selectedCannonId;
            if (finalCannonId === 'random') {
                finalCannonId = selectRandomCannon();
            }
            
            // 2. æ‡‰ç”¨è§’è‰²é…ç½®
            currentCannonConfig = CANNONS_CONFIG[finalCannonId];
            cannonImage = currentCannonConfig.image;
            if (!cannonImage.isLoaded) {
                 console.warn(`Warning: Cannon image for ${currentCannonConfig.name} is not loaded.`);
            }

            autoFireInterval = BASE_AUTO_FIRE_INTERVAL * currentCannonConfig.fireRateMultiplier;
            
            // 3. å˜—è©¦æ’­æ”¾ä¸€æ¬¡è²éŸ³ä»¥è§£é–ç€è¦½å™¨éŸ³è¨Š
            playSfx(sfx.LASER, 0.0);
            
            // 4. åˆå§‹åŒ–éŠæˆ²ç‹€æ…‹
            initGame();
            
            isGameStarted = true;
            messageBox.style.display = 'none';

            // éš±è—æ¨™é¡Œï¼Œå°‡ body é ‚éƒ¨å°é½Šï¼Œæœ€å¤§åŒ–éŠæˆ²ç•«å¸ƒç©ºé–“
            gameTitleElement.style.display = 'none';
            bodyElement.classList.add('game-active');
            
            // é‡æ–°èª¿æ•´å°ºå¯¸ä»¥é©æ‡‰æ¨™é¡Œéš±è—å¾Œçš„ç©ºé–“è®ŠåŒ–
            resizeCanvas();

            if (!gameLoopRunning) {
                gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function showGameOver(title, message) {
            isGameOver = true;
            gameLoopRunning = false;
            
            messageTitle.textContent = title;
            messageText.innerHTML = `${message}<br>${score} å€‹éœ‰é‹ï¼`; // Final Score message adjusted
            selectionContainer.innerHTML = ''; // æ¸…é™¤é¸æ“‡ä»‹é¢
            
            // ç§»é™¤èˆŠçš„æŒ‰éˆ• (é™¤äº† startRestartButton)
            let oldDownloadButton = document.getElementById('downloadScoreCardButton');
            if (oldDownloadButton) oldDownloadButton.remove();
            
            // å‰µå»ºä¸¦æ’å…¥ä¸‹è¼‰æŒ‰éˆ•
            const downloadButton = document.createElement('button');
            downloadButton.id = 'downloadScoreCardButton';
            downloadButton.className = 'control-button secondary';
            downloadButton.textContent = 'ä¸‹è¼‰æˆ°ç¸¾å¡ (PNG)';
            downloadButton.addEventListener('click', downloadScoreCard);
            messageBox.insertBefore(downloadButton, startRestartButton);

            startRestartButton.textContent = 'é‡æ–°é–‹å§‹'; // Restart button
            
            // æº–å‚™æˆ°ç¸¾å¡æ•¸æ“š
            prepareScoreCard(score, difficultyLevel, currentCannonConfig, cannonCount);
            
            messageBox.style.display = 'flex';
            
            // é¡¯ç¤ºæ¨™é¡Œï¼Œå°‡ body å…§å®¹å±…ä¸­
            gameTitleElement.style.display = 'block';
            bodyElement.classList.remove('game-active');
        }
        
        // ----------------------------------------------------
        // ğŸ¯ æˆ°ç¸¾å¡ä¸‹è¼‰é‚è¼¯
        // ----------------------------------------------------
        function prepareScoreCard(finalScore, finalLevel, cannonConfig, finalCannonCount) {
             // ç¢ºä¿æˆ°ç¸¾å¡å¯è¦‹ (ä½†ä»ç§»å‡ºè¦–çª—å¤–ï¼Œå› ç‚º html2canvas å¿…é ˆåœ¨ DOM ä¸­æ‰¾åˆ°å…ƒç´ )
            scoreCardTemplate.style.position = 'absolute';
            scoreCardTemplate.style.left = '-9999px';
            scoreCardTemplate.style.zIndex = '100'; // ç¢ºä¿åœ¨é ‚å±¤ï¼Œå„˜ç®¡åœ¨å±å¹•å¤–
            
            // 1. è¨­ç½®æœ€çµ‚åˆ†æ•¸
            document.getElementById('finalScore').textContent = finalScore;
            
            // 2. ä¿®æ­£ç¨±è¬‚ï¼šæˆ°æ©Ÿ -> ä½¿ç”¨
            document.getElementById('scoreCardCannonName').textContent = `${cannonConfig.name}`;
            
            // 3. ä¿®æ­£ç­‰ç´šé¡¯ç¤ºï¼šç§»é™¤ LV.
            document.getElementById('scoreCardLevel').textContent = `LV.${finalLevel}`;
            
            // 4. ä¿®æ­£ç«åŠ›ç¨±è™Ÿ
            let firepowerTitle;
            switch (finalCannonCount) {
                case 1:
                    firepowerTitle = "æ‚¨æ˜¯éˆæ ¹å‰å‰å­¸å¾’ï¼";
                    break;
                case 2:
                    firepowerTitle = "æ‚¨æ˜¯éˆæ ¹å‰å‰å°ˆå®¶ï¼";
                    break;
                case 3:
                    firepowerTitle = "æ‚¨æ˜¯éˆæ ¹å‰å‰å¤§å¸«ï¼";
                    break;
                default:
                    firepowerTitle = `ç«åŠ›ï¼šx${finalCannonCount} éˆæ ¹`; // Fallback
            }
            document.getElementById('scoreCardCannonCount').textContent = firepowerTitle;

            // 5. è¨­ç½®åœ–ç‰‡
            document.getElementById('scoreCardCannonImage').src = cannonConfig.url;
            document.getElementById('scoreCardCannonImage').alt = cannonConfig.name;
        }

        function downloadScoreCard() {
            const downloadButton = document.getElementById('downloadScoreCardButton');
            downloadButton.disabled = true;
            downloadButton.textContent = 'æ­£åœ¨ç”Ÿæˆ...';

            // èª¿æ•´æ¨¡æ¿ä»¥ç¢ºä¿æ‰€æœ‰å…§å®¹éƒ½èƒ½æ­£ç¢ºæ¸²æŸ“ (é›–ç„¶å·²ç¶“æ˜¯å›ºå®šå°ºå¯¸ï¼Œä½†é‚„æ˜¯ç¢ºä¿å…¶å°ºå¯¸)
            scoreCardTemplate.style.width = '400px'; 
            scoreCardTemplate.style.height = '600px';

            html2canvas(scoreCardTemplate, {
                // å¿…é ˆè¨­å®šæ»¾å‹•ä½ç½®ï¼Œå› ç‚ºæ¨¡æ¿è¢«ç§»åˆ°è¢å¹•å¤–äº†
                scrollX: 0,
                scrollY: 0,
                // è¨­å®šç²¾ç¢ºçš„å¯¬é«˜ä»¥ç¢ºä¿åœ–ç‰‡å°ºå¯¸ä¸€è‡´
                width: 400,
                height: 600,
                scale: 2 // æé«˜è§£æåº¦ä»¥ç²å¾—æ›´æ¸…æ™°çš„åœ–ç‰‡ (800x1200)
            }).then(canvas => {
                downloadButton.textContent = 'ä¸‹è¼‰å®Œæˆï¼';
                downloadButton.disabled = false;
                
                // å‰µå»ºä¸‹è¼‰é€£çµ
                const link = document.createElement('a');
                link.download = `éˆæ ¹å‰å‰æˆ°ç¸¾_${score}.png`;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // é‡è¨­æŒ‰éˆ•æ–‡å­—
                setTimeout(() => {
                    downloadButton.textContent = 'ä¸‹è¼‰æˆ°ç¸¾å¡ (PNG)';
                }, 2000);
            }).catch(error => {
                console.error("ç”Ÿæˆæˆ°ç¸¾å¡æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
                downloadButton.textContent = 'ç”Ÿæˆå¤±æ•—ï¼';
                downloadButton.disabled = false;
            });
        }
        // ----------------------------------------------------
        // å¤§çµ•æ‹›é‚è¼¯
        // ----------------------------------------------------

         function fireSuperBomb() {
            if (superBombs < 1 || isGameOver) return;
            
            playSfx(sfx.ULTIMATE_BOOM, 1.0, 1.0); // æ’­æ”¾å¤§çµ•éŸ³æ•ˆ

            // 1. æ¸…ç©ºæ‰€æœ‰é»´èŒå’Œå­å½ˆ
            const moldsCleared = mold.length;
            mold = [];
            bullets = [];
            
            // 2. æ‡‰ç”¨åˆ†æ•¸çå‹µ
            // æ¯å€‹æ¸…é™¤çš„é»´èŒçµ¦äºˆ 20 é¡å¤–åˆ†æ•¸
            const bonusScore = moldsCleared * 20; 
            updateScore(bonusScore); 

            // 3. è§¸ç™¼è¶…å¤§çˆ†ç‚¸è¦–è¦ºå’Œéœ‡å‹•æ•ˆæœ
            isSuperExploding = true;
            superExplosionStartTime = performance.now(); // è¨˜éŒ„é–‹å§‹æ™‚é–“
            
            // ğŸ¯ åœ¨é€™è£¡åŠ å…¥ GIF é¡¯ç¤ºé‚è¼¯
            ultimateGif.style.display = 'block';
            // é€éé‡è¨­ src å¼·åˆ¶ GIF å¾é ­æ’­æ”¾
            const gifSrc = ultimateGif.src; 
            ultimateGif.src = '';
            ultimateGif.src = gifSrc;
            // ---------------------------------
            
            // 4. é‡ç½®ç‹€æ…‹
            superBombs = 0;
            superBombCharge = 0;
            updateChargeDisplay();
        }

        // ----------------------------------------------------
        // éŠæˆ²è¼¸å…¥è™•ç†
        // ----------------------------------------------------

        function handleInput() {
            if (isGameStarted && !isGameOver) {
                const step = cannon.speed;
                const formationWidth = (cannonCount - 1) * CANNON_SPACING + cannon.imgWidth;
                const halfFormationWidth = formationWidth / 2;
                
                // ğŸ¯ cannon.x ä»£è¡¨ç·¨éšŠçš„ä¸­å¿ƒ X åº§æ¨™

                if (leftPressed) {
                    const newCenterX = cannon.x - step;
                    // æª¢æŸ¥å·¦é‚Šç•Œ (ä¸­å¿ƒ - åŠå¯¬ >= 0)
                    if (newCenterX - halfFormationWidth >= 0) {
                        cannon.x = newCenterX;
                    } else {
                        cannon.x = halfFormationWidth; // è²¼é½Šå·¦é‚Š
                    }
                }
                if (rightPressed) {
                    const newCenterX = cannon.x + step;
                    // æª¢æŸ¥å³é‚Šç•Œ (ä¸­å¿ƒ + åŠå¯¬ <= canvas.width)
                    if (newCenterX + halfFormationWidth <= canvas.width) {
                        cannon.x = newCenterX;
                    } else {
                        cannon.x = canvas.width - halfFormationWidth; // è²¼é½Šå³é‚Š
                    }
                }
            }
        }
        
        function handleCanvasControl(e) {
            if (messageBox.style.display !== 'none' || !isGameStarted || isGameOver) return;
            
            let clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
            if (e.touches) e.preventDefault(); // é˜»æ­¢ç§»å‹•ç«¯é è¨­è¡Œç‚º
            
            const rect = canvas.getBoundingClientRect();
            const touchX = clientX - rect.left; 
            
            // æ ¹æ“šé»æ“Šä½ç½®æ±ºå®šç§»å‹•æ–¹å‘
            const centerX = cannon.x;
            if (touchX < centerX) {
                leftPressed = true;
                rightPressed = false;
            } else {
                rightPressed = true;
                leftPressed = false;
            }
        }
        
        function stopMovement() {
            leftPressed = false;
            rightPressed = false;
        }

        // è¨»å†Šç•«å¸ƒäº‹ä»¶ç›£è½å™¨
        canvas.addEventListener('mousedown', handleCanvasControl);
        canvas.addEventListener('touchstart', handleCanvasControl, { passive: false }); 
        canvas.addEventListener('mouseup', stopMovement);
        canvas.addEventListener('touchend', stopMovement);
        canvas.addEventListener('mouseleave', stopMovement); 
        
        // è¨»å†Šå¤§çµ•æ‹›æŒ‰éˆ•äº‹ä»¶
        superBombButton.addEventListener('click', fireSuperBomb);
        
        // éµç›¤äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = true;
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = true;
            } else if ((e.key === ' ' || e.key === 'Enter') && superBombs > 0) {
                fireSuperBomb();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = false;
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = false;
            }
        });

        // é–‹å§‹/é‡æ–°é–‹å§‹æŒ‰éˆ•äº‹ä»¶
        startRestartButton.addEventListener('click', () => {
            if (isGameStarted && isGameOver) {
                initGame();
                showCharacterSelection();
            } else if (!isGameStarted) {
                startGame();
            }
        });

        // ----------------------------------------------------
        // å°„æ“Šã€æ›´æ–°ã€ç¢°æ’é‚è¼¯ 
        // ----------------------------------------------------
        
        function getCannonShotRate(cannonName) {
            if (cannonName.includes('ç ´é­”')) return 0.8; 
            if (cannonName.includes('è±ç››')) return 1.2;
            return 1.0; 
        }

        function fireBullet() {
            const { bulletRadius, bulletColor, bulletDurability, name } = currentCannonConfig;
            
            // æ’­æ”¾å°„æ“ŠéŸ³æ•ˆï¼Œä¸¦æ ¹æ“šæ©Ÿé«”é¡å‹èª¿æ•´æ’­æ”¾é€Ÿç‡
            playSfx(sfx.LASER, 0.5, getCannonShotRate(name));

            const cannonPositions = getCannonPositions();

            // ğŸ¯ é‡å°æ¯ä¸€å€‹ç‚®å°ä½ç½®ç™¼å°„å­å½ˆ
            cannonPositions.forEach(pos => {
                const bulletX = pos.centerX;

                if (name.includes('ç ´é­”')) {
                    bullets.push({
                        x: bulletX,
                        y: cannon.y,
                        radius: bulletRadius,
                        color: bulletColor,
                        durability: bulletDurability,
                        type: 'pomo', 
                        hSpeed: 0
                    });
                } else if (name.includes('æ­£ç·£')) {
                    for (let i = -1; i <= 1; i++) {
                        bullets.push({
                            x: bulletX + i * 5, 
                            y: cannon.y,
                            radius: bulletRadius,
                            color: bulletColor,
                            durability: 1, 
                            type: 'zhengyuan',
                            hSpeed: i * 0.5
                        });
                    }
                } else {
                    bullets.push({
                        x: bulletX,
                        y: cannon.y,
                        radius: bulletRadius,
                        color: bulletColor,
                        durability: 1,
                        type: 'normal',
                        hSpeed: 0
                    });
                }
            });
        }

        function updateGame(deltaTime) {
            const now = performance.now();

            handleInput();

            if (now - lastFireTime > autoFireInterval) {
                fireBullet();
                lastFireTime = now;
            }

            bullets = bullets.filter(bullet => {
                bullet.y -= 8;
                bullet.x += bullet.hSpeed || 0;
                return bullet.y + bullet.radius > 0;
            });

            updateMolds(deltaTime, now);
            
            if (now - lastMoldSpawnTime > moldSpawnInterval) {
                const type = MOLD_TYPES_SEQUENCE[moldTypeCounter % MOLD_TYPES_SEQUENCE.length];
                mold.push(createMold(type, moldSpeed));
                moldTypeCounter++;
                lastMoldSpawnTime = now;
            }
            
            checkCollisions(deltaTime);
            updateExplosions(deltaTime);

            if (lives <= 0) {
                showGameOver('éˆæ ¹èƒ½é‡ç”¨ç½„', 'æ­å–œæ‚¨ï¼Œå·²ç¶“æ·¨åŒ–äº†');
            }
        }
        
        function updateMolds(deltaTime, now) {
            // ğŸ¯ è¨ˆç®—ç•¶å‰ç‚®å°ç·¨éšŠçš„é‚Šç•Œ
            const formationWidth = (cannonCount - 1) * CANNON_SPACING + cannon.imgWidth;
            const halfFormationWidth = formationWidth / 2;

            const formationX_left = cannon.x - halfFormationWidth; 
            const formationX_right = cannon.x + halfFormationWidth; 

            mold = mold.filter(m => {
                m.y += m.ySpeed;

                if (m.type === 'lively') {
                    m.x += m.hSpeed;
                    if (m.x - m.radius < 0 || m.x + m.radius > canvas.width) m.hSpeed *= -1;
                } else if (m.type === 'weaving') {
                    if (now - m.weaveTimer > 1000) {
                        m.hSpeed *= -1;
                        m.weaveTimer = now;
                    }
                    m.x += m.hSpeed;
                    if (m.x - m.radius < 0) { m.x = m.radius; m.hSpeed = Math.abs(m.hSpeed); }
                    if (m.x + m.radius > canvas.width) { m.x = canvas.width - m.radius; m.hSpeed = -Math.abs(m.hSpeed); }
                } else if (m.type === 'dashing') {
                    m.dashTimer -= deltaTime;
                    if (m.dashTimer < 0 && !m.isDashing) {
                        m.isDashing = true;
                        m.dashTimer = 500; 
                    }
                    if (m.isDashing) {
                        m.y += m.ySpeed * 5; 
                        m.dashTimer -= deltaTime;
                        if (m.dashTimer <= 0) {
                            m.isDashing = false;
                            m.dashTimer = m.dashInterval + Math.random() * 1500;
                        }
                    }
                }

                if (m.isHit) {
                    m.hitTimer -= deltaTime;
                    if (m.hitTimer <= 0) m.isHit = false;
                }

                if (m.y - m.radius > canvas.height) return false; 

                // ğŸ¯ ç¢°æ’æª¢æ¸¬ - è§’è‰² (æª¢æŸ¥èˆ‡æ•´å€‹ç·¨éšŠçš„çŸ©å½¢ç¢°æ’)
                if (
                    m.y + m.radius >= cannon.y && m.y - m.radius <= cannon.y + cannon.height &&
                    m.x + m.radius >= formationX_left && m.x - m.radius <= formationX_right
                ) {
                    lives--;
                    updateLivesDisplay();
                    triggerDamageEffect(now);
                    createExplosion(m.x, m.y, m.radius, m.color);
                    return false; 
                }

                return true;
            });
        }
        
        function checkCollisions(deltaTime) {
            const nextBullets = [];
            const moldsToKeep = [];

            mold.forEach(m => {
                let moldHitThisFrame = false; // ç”¨æ–¼é¿å…é‡è¤‡æ’­æ”¾æ“Šä¸­éŸ³æ•ˆ

                bullets.forEach(b => {
                    const dx = b.x - m.x;
                    const dy = b.y - m.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < b.radius + m.radius) {
                        
                        let damage = (b.type === 'pomo' && m.type === 'huge') ? 3 : 1;
                        const healthBeforeHit = m.health;
                        
                        m.health -= damage;
                        m.isHit = true;
                        m.hitTimer = 100;
                        moldHitThisFrame = true; // æ¨™è¨˜è¢«æ“Šä¸­

                        // ğŸ¯ è£ç”²é»´èŒé¡è‰²è®ŠåŒ–
                        if (m.type === 'armored' && m.health < healthBeforeHit && m.health <= m.armoredThreshold) {
                             m.color = m.unarmoredColor; // è¡€é‡ä½æ–¼é–€æª»æ™‚æ”¹è®Šé¡è‰²
                        }
                        
                        // ğŸ¯ å·¨å¤§é»´èŒå°ºå¯¸è®ŠåŒ– (ä½¿ç”¨ initialHealth ç¢ºä¿æ¯”ä¾‹ç©©å®š)
                        if (m.type === 'huge') {
                            const healthRatio = m.health / m.initialHealth;
                            if (healthRatio <= 1/3 && m.radius > m.normalRadius) m.radius = m.normalRadius;
                            else if (healthRatio <= 2/3 && m.radius > m.medRadius) m.radius = m.medRadius;
                        }
                        
                        if (m.health <= 0) {
                            // æ“Šæ¯€éŸ³æ•ˆ (Pop.mp3, æ­£å¸¸æ’­æ”¾)
                            playSfx(sfx.POP, 0.7, 1.0); 
                            
                            let basePoints = 10;
                            switch (m.type) {
                                case 'fast': basePoints = 25; break;
                                case 'armored': basePoints = 30; break;
                                case 'weaving': basePoints = 35; break;
                                case 'sturdy': basePoints = 40; break;
                                case 'huge': basePoints = 50; break;
                                case 'lively': basePoints = 20; break;
                                case 'dashing': basePoints = 30; break;
                                default: basePoints = 10; break;
                            }
                            
                            // ğŸ¯ æ‡‰ç”¨é›£åº¦åˆ†æ•¸ç­‰ç´šçš„åˆ†æ•¸ä¹˜æ•¸ï¼Œä¸¦å››æ¨äº”å…¥
                            const points = Math.round(basePoints * currentScoreFactor);

                            updateScore(points);
                            createExplosion(m.x, m.y, m.radius, m.color);
                        } else if (healthBeforeHit > 0) {
                            // æ“Šä¸­éŸ³æ•ˆ (Pop.mp3, å¿«é€Ÿé«˜éŸ³)
                            playSfx(sfx.POP, 0.3, 1.5); 
                        }

                        b.durability--;
                    }
                });

                if (m.health > 0) moldsToKeep.push(m);
            });
            
            bullets.forEach(b => {
                if (b.durability > 0) nextBullets.push(b);
            });

            mold = moldsToKeep;
            bullets = nextBullets;
        }

        // ----------------------------------------------------
        // è¦–è¦ºç‰¹æ•ˆè™•ç†
        // ----------------------------------------------------
        
        function createExplosion(x, y, radius, color) {
            explosions.push({
                x: x,
                y: y,
                radius: radius,
                color: color,
                maxRadius: radius * 3,
                alpha: 1.0,
                speed: 10
            });
        }

        function updateExplosions(deltaTime) {
            explosions = explosions.filter(exp => {
                exp.radius += exp.speed * (deltaTime / 16.67);
                exp.alpha -= 0.05 * (deltaTime / 16.67);
                return exp.alpha > 0;
            });
        }
        
        function triggerDamageEffect(now) {
            damageEffectActive = true;
            damageStartTime = now;
        }

        function getShakeOffset(now) {
            let shakeOffset = 0;
            
            // 1. å‚·å®³éœ‡å‹•
            if (damageEffectActive) {
                const elapsed = now - damageStartTime;
                if (elapsed < DAMAGE_DURATION) {
                    shakeOffset = 5 * (1 - elapsed / DAMAGE_DURATION);
                } else {
                    damageEffectActive = false;
                }
            }
            
            // 2. çˆ†ç‚¸éœ‡å‹• (è¦†è“‹å‚·å®³éœ‡å‹•)
            if (isSuperExploding) {
                const elapsed = now - superExplosionStartTime;
                if (elapsed < SUPER_EXPLOSION_DURATION) {
                    const progress = elapsed / SUPER_EXPLOSION_DURATION;
                    // å¾æœ€å¤§å¼·åº¦éæ¸›
                    shakeOffset = SUPER_SHAKE_INTENSITY * (1 - progress); 
                } else {
                    isSuperExploding = false; // éœ‡å‹•çµæŸ
                    ultimateGif.style.display = 'none'; // ğŸ¯ çˆ†ç‚¸çµæŸæ™‚éš±è— GIF
                }
            }

            return shakeOffset;
        }
        
        // ----------------------------------------------------
        // ç¹ªåœ–é‚è¼¯
        // ----------------------------------------------------

        function drawGame() {
            if (!gameLoopRunning && !isGameStarted) return;
            
            const now = performance.now();

            ctx.fillStyle = getBackgroundColor(difficultyLevel);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ‡‰ç”¨ç•«é¢éœ‡å‹•æ•ˆæœ
            const currentShakeOffset = getShakeOffset(now);
            const dx = currentShakeOffset > 0 ? Math.sin(now * 0.5) * currentShakeOffset : 0;
            const dy = currentShakeOffset > 0 ? Math.cos(now * 0.5) * currentShakeOffset : 0;
            ctx.save();
            ctx.translate(dx, dy);

            // 1. ç¹ªè£½é»´èŒ
            mold.forEach(m => {
                if (m.isHit && Math.floor(m.hitTimer / 50) % 2 === 0) {
                    ctx.fillStyle = '#ecf0f1';
                } else {
                    ctx.fillStyle = m.color;
                }
                
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();
                
                if (m.type === 'dashing' && !m.isDashing && m.dashTimer < 1000 && m.dashTimer > 0) {
                    const alpha = (1000 - m.dashTimer) / 1000 * 0.5;
                    ctx.fillStyle = `rgba(231, 76, 60, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, m.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ğŸ¯ ç¹ªè£½è¡€æ¢ (ä½¿ç”¨ initialHealth)
                if (m.initialHealth > 1) {
                    const healthRatio = m.health / m.initialHealth;
                    const barWidth = m.radius * 2;
                    const barHeight = 4;
                    const barX = m.x - m.radius;
                    const barY = m.y - m.radius - 8;
                    
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = healthRatio > 0.5 ? '#2ecc71' : (healthRatio > 0.25 ? '#f1c40f' : '#e74c3c');
                    ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
                }
            });

            // 2. ç¹ªè£½å­å½ˆ
            bullets.forEach(b => {
                if (b.type === 'pomo') {
                    const durabilityRatio = b.durability / currentCannonConfig.bulletDurability;
                    ctx.fillStyle = `rgba(52, 152, 219, ${0.4 + durabilityRatio * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = '8px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(b.durability, b.x, b.y);
                } else {
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // 3. ç¹ªè£½çˆ†ç‚¸æ•ˆæœ
            explosions.forEach(exp => {
                ctx.fillStyle = exp.color;
                ctx.globalAlpha = exp.alpha;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });

            // 4. ğŸ¯ ç¹ªè£½ç‚®å°ç·¨éšŠ
            const cannonPositions = getCannonPositions();
            cannonPositions.forEach(pos => {
                if (cannonImage.isLoaded) {
                    ctx.drawImage(
                        cannonImage,
                        pos.drawX, // ä½¿ç”¨æ–°çš„ç¹ªåœ– X åº§æ¨™
                        cannon.y,
                        cannon.imgWidth,
                        cannon.imgHeight
                    );
                } else {
                    // Fallback: ç¹ªè£½æ–¹å¡Š
                    ctx.fillStyle = 'red';
                    ctx.fillRect(pos.drawX, cannon.y, cannon.width, cannon.height);
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(currentCannonConfig.name.replace('éˆæ ¹', ''), pos.centerX, cannon.y + cannon.height / 2);
                }
            });
            
            // æ¢å¾©ç•«å¸ƒç‹€æ…‹
            ctx.restore();
            
            // 5. ç¹ªè£½è¶…ç´šçˆ†ç‚¸æ•ˆæœ
            if (isSuperExploding) {
                const elapsed = now - superExplosionStartTime;
                const progress = elapsed / SUPER_EXPLOSION_DURATION;
                
                let radius = canvas.width * 0.8 * progress; 
                let alpha = 1.0 - progress;

                ctx.globalAlpha = Math.max(0, alpha * 0.9);
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // ----------------------------------------------------
        // éŠæˆ²ä¸»å¾ªç’°
        // ----------------------------------------------------
        let lastTime = 0;

        function gameLoop(currentTime) {
            if (!gameLoopRunning) return;

            const deltaTime = Math.min(currentTime - lastTime, 100); 
            lastTime = currentTime;
            
            if (!isGameOver) {
                updateGame(deltaTime);
            }
            drawGame();

            requestAnimationFrame(gameLoop);
        }

        // ----------------------------------------------------
        // å•Ÿå‹•é»
        // ----------------------------------------------------

        // ç¢ºä¿åœ¨æ‰€æœ‰ DOM å…ƒç´ è¼‰å…¥å¾Œé¡¯ç¤ºé¸æ“‡ç•«é¢
        window.onload = function() {
            resizeCanvas(); 
            initGame();
            showCharacterSelection();
        };

        // ----------------------------------------------------
        // è§’è‰²é¸æ“‡èˆ‡ç•«é¢é¡¯ç¤º
        // ----------------------------------------------------

        function showCharacterSelection() {
            selectionContainer.innerHTML = '';
            messageTitle.textContent = 'é¸æ“‡æ‚¨çš„éˆæ ¹';
            startRestartButton.textContent = 'å‡ºç™¼'; 
            
            // ç§»é™¤å¯èƒ½å­˜åœ¨çš„ä¸‹è¼‰æŒ‰éˆ•
            let oldDownloadButton = document.getElementById('downloadScoreCardButton');
            if (oldDownloadButton) oldDownloadButton.remove();
            
            messageText.textContent = CANNONS_CONFIG[selectedCannonId].description || '';

            Object.keys(CANNONS_CONFIG).forEach(id => {
                const cannon = CANNONS_CONFIG[id];
                const card = document.createElement('div');
                card.id = `card-${id}`;
                card.className = 'cannon-card';
                
                const img = document.createElement('img');
                img.src = cannon.url;
                img.width = CANNON_COLLISION_SIZE;
                img.height = CANNON_COLLISION_SIZE;

                const nameLabel = document.createElement('p');
                nameLabel.textContent = cannon.name.replace('éˆæ ¹', ''); // é¸æ“‡ç•«é¢åªé¡¯ç¤ºåç¨±

                card.appendChild(img);
                card.appendChild(nameLabel);
                selectionContainer.appendChild(card);

                card.addEventListener('click', () => selectCannon(id));
            });
            
            selectCannon(selectedCannonId);
            messageBox.style.display = 'flex';
        }

        function selectCannon(id) {
            selectedCannonId = id;
            document.querySelectorAll('.cannon-card').forEach(card => {
                card.classList.remove('selected');
                if (card.id === `card-${id}`) {
                    card.classList.add('selected');
                }
            });
            const selectedConfig = CANNONS_CONFIG[id];
            messageText.textContent = selectedConfig.description;
        }

        function initGame() {
            score = 0;
            lives = 3;
            isGameOver = false;
            isGameStarted = false;
            bullets = [];
            mold = [];
            explosions = [];
            
            difficultyLevel = 1;
            nextDifficultyScore = DIFFICULTY_STEP_SCORE;
            moldSpeed = MOLD_BASE_SPEED;
            moldSpawnInterval = 1000;
            
            superBombCharge = 0;
            superBombs = 0;
            isSuperExploding = false;

            // ğŸ¯ éˆæ ¹å‡ç´šç‹€æ…‹åˆå§‹åŒ–
            cannonCount = 1;
            nextCannonThreshold = CANNON_UPGRADE_THRESHOLD_1;
            
            // ğŸ¯ é›£åº¦éš¨åˆ†æ•¸å¢åŠ ç‹€æ…‹åˆå§‹åŒ–
            scoreTier = 0;
            nextScoreTierThreshold = SCORE_TIER_THRESHOLD;
            currentHealthFactor = 1.0;
            currentScoreFactor = 1.0; 

            gameTitleElement.style.display = 'block';
            bodyElement.classList.remove('game-active');

            // ğŸ¯ é‡æ–°å®šç¾© cannon.x ç‚ºç·¨éšŠçš„ä¸­å¿ƒé»
            cannon.width = CANNON_COLLISION_SIZE;
            cannon.height = CANNON_COLLISION_SIZE;
            cannon.imgWidth = CANNON_DISPLAY_SIZE;
            cannon.imgHeight = CANNON_DISPLAY_SIZE;
            cannon.x = canvas.width / 2; // ä¸­å¿ƒ X åº§æ¨™
            cannon.y = canvas.height - CANNON_COLLISION_SIZE - 10;
            cannon.speed = 6;
            
            scoreDisplay.textContent = score;
            levelDisplay.textContent = difficultyLevel;
            cannonCountDisplay.textContent = cannonCount;

            updateLivesDisplay();
            updateChargeDisplay();
            
            requestAnimationFrame(drawGame);
        }
    </script>
</body>
</html>
