<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>靈根吉吉射爆霉運</title>
    <!-- 引入 html2canvas 庫，用於將 HTML 元素轉換為圖片 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* 使用 Tailwind 概念的自定義CSS讓遊戲看起來更美觀，並確保移動端友好 */
        html, body {
            height: 100%; /* 確保 HTML 和 Body 佔滿整個視窗 */
            margin: 0;
            /* 🎯 確保內容不被系統 UI 遮擋 */
            overflow: hidden; 
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 預設居中所有內容 */
            justify-content: center; 
            min-height: 100vh;
            background-color: #2c3e50; /* 深藍色背景 */
            font-family: 'Inter', sans-serif;
            color: #ecf0f1;
            box-sizing: border-box;
            
            /* 🎯 核心修正：將所有邊界空間和安全區都設定在 body padding */
            padding-top: 5px; /* 模擬原先 game-container 的頂部 5px margin */
            /* 調整 padding-bottom 以確保 footer 有空間，並考慮系統安全區 */
            padding-bottom: env(safe-area-inset-bottom, 0px); 
        }
        
        /* 遊戲狀態下的 body 樣式調整，讓內容更靠頂部 */
        body.game-active {
            justify-content: flex-start;
        }

        #game-title {
            margin: 0 0 5px 0; /* 極小的底部間距 */
            text-align: center;
            width: 100%;
        }
        #game-title h1 {
            font-size: 1.8em;
            color: #f1c40f;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            margin: 0;
        }

        #game-container {
            width: 100%; /* 佔滿可用寬度 */
            max-width: 720px; /* 限制最大寬度 */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            background-color: #34495e;
            position: relative;
            
            /* 關鍵改動：移除 margin，使用 body padding 控制邊距 */
            margin: 0; 
            
            /* 關鍵改動：使用 100% height 佔滿 body 內剩餘空間 */
            display: flex;
            flex-direction: column;
            flex-grow: 1; 
            height: 100%;
            max-height: 90%; 
        }

        #gameCanvas {
            display: block;
            width: 100%;
            /* 關鍵改動：佔用所有垂直剩餘空間 */
            flex-grow: 1; 
            min-height: 200px; /* 確保最小高度 */
            cursor: pointer; 
        }

        #ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 0.8em;
            background-color: #2c3e50;
            /* 確保 UI panel 不會被壓縮 */
            flex-shrink: 0; 
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }
        
        .game-info {
            font-weight: bold;
            flex: 1;
            text-align: center;
            white-space: nowrap; /* 防止文字換行 */
        }
        .game-info:first-child { text-align: left; }
        .game-info:last-child { text-align: right; }

        /* ------------------------------------- */
        /* 生命值指示燈樣式 */
        .life-indicators {
            display: flex;
            gap: 5px;
            justify-content: center;
        }
        .life-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid #ecf0f1;
            transition: background-color 0.3s;
        }
        .life-green { background-color: #2ecc71; }
        .life-yellow { background-color: #f1c40f; }
        .life-red { background-color: #e74c3c; }
        .life-grey { background-color: #7f8c8d; }
        /* ------------------------------------- */

        /* ------------------------------------- */
        /* 充能條樣式 */
        .charge-info {
            flex: 2; /* 給予充能條更多空間 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .charge-bar-wrapper {
            display: inline-block;
            width: 60px;
            height: 8px;
            background-color: #7f8c8d;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #bdc3c7;
            vertical-align: middle;
            margin-left: 5px;
        }
        .charge-fill {
            height: 100%;
            width: 0%;
            background-color: #3498db;
            transition: width 0.1s;
        }
        /* ------------------------------------- */
        
        /* ------------------------------------- */
        /* Super Bomb Button Style */
        #superBombButton {
            position: absolute;
            /* 放置在畫布的右下方，讓開砲台和底部 UI 面板 */
            bottom: calc(75px + 10px); /* 10px 是 UI-Panel 的 padding-top/bottom */
            right: 15px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid #f1c40f;
            background-color: #34495e;
            color: #ecf0f1;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 5;
            opacity: 0.5;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            /* 預設狀態：不干擾畫布點擊 */
            pointer-events: none; 
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
        }
        /* 充能完畢時的樣式 */
        #superBombButton.ready {
            background-color: #e74c3c; /* 亮紅色 */
            opacity: 1.0;
            transform: scale(1.1);
            pointer-events: auto; /* 啟用點擊 */
            box-shadow: 0 0 15px #e74c3c, 0 0 5px #f1c40f;
        }
        #superBombButton:active.ready {
            transform: scale(1.0);
            box-shadow: 0 0 5px #e74c3c;
        }
        /* ------------------------------------- */

        /* 遊戲開始/結束訊息框 (保持不變) */
        #messageBox {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.95);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            font-size: 1.0em;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            gap: 10px;
            transition: opacity 0.3s;
        }
        #messageBox h2 {
            font-size: 1.0em;
            margin-bottom: 5px;
        }
        #messageBox p {
            font-size: 0.8em;
            margin: 0;
        }
        
        /* 額外為遊戲結束畫面添加戰績卡按鈕樣式 */
        .control-button {
            padding: 8px 15px; 
            font-size: 0.8em; 
            font-weight: bold;
            color: white;
            background-color: #e74c3c;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px #c0392b;
            transition: background-color 0.1s, box-shadow 0.1s, transform 0.1s;
            margin-top: 5px;
        }
        .control-button.secondary {
             background-color: #3498db;
             box-shadow: 0 4px #2980b9;
        }
        .control-button:active {
            box-shadow: 0 0;
            transform: translateY(4px);
        }

        /* 角色選擇容器: 2x2 Grid Layout (保持不變) */
        #selection-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 兩列等寬 */
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
            width: 90%;
            max-width: 250px; 
        }
        
        /* 角色卡片樣式 (保持不變) */
        .cannon-card {
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            border: 3px solid transparent;
            transition: all 0.2s;
            background-color: #34495e;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            width: 100%; 
            box-sizing: border-box;
        }
        .cannon-card:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }
        .cannon-card.selected {
            border-color: #f1c40f;
            transform: scale(1.05);
        }
        .cannon-card img {
            width: 45px;
            height: 45px;
            border-radius: 4px;
        }
        .cannon-card p {
            font-size: 0.7em;
            font-weight: bold;
            margin-top: 5px;
        }
        
        /* ------------------------------------- */
        /* 底部版權資訊樣式 */
        /* ------------------------------------- */
        #game-footer {
            flex-shrink: 0; /* 確保不被壓縮 */
            width: 100%;
            max-width: 600px;
            text-align: center;
            font-size: 0.7em;
            color: #7f8c8d; /* 淺灰色文字 */
            padding: 10px 0 5px 0; /* 頂部間距和底部微小空間 */
            user-select: none;
        }
        
        /* ------------------------------------- */
        /* 🎯 戰績卡模板樣式 (用於生成圖片，必須是絕對尺寸，建議使用 px) */
        /* ------------------------------------- */
        #scoreCardTemplate {
            position: absolute; /* 不佔用空間 */
            left: -9999px; /* 移出視窗外 */
            top: 0;
            width: 400px; /* 固定寬度，適合 PNG 輸出 */
            height: 600px; /* 固定高度 */
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); /* 漸變背景 */
            color: #ecf0f1;
            font-family: 'Inter', sans-serif;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            text-align: center;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            z-index: -100;
        }
        
        #scoreCardTemplate .title {
            font-size: 1.8em;
            color: #f1c40f;
            font-weight: 900;
            text-shadow: 0 0 5px rgba(241, 196, 15, 0.8);
            margin-bottom: 10px;
        }
        
        #scoreCardTemplate #finalScore {
            font-size: 6em; /* 超大字體分數 */
            font-weight: bold;
            color: #2ecc71; /* 綠色分數 */
            text-shadow: 0 0 10px rgba(46, 204, 113, 0.7);
            line-height: 1;
            margin: 10px 0;
        }
        
        #scoreCardTemplate #cannonImage {
            width: 100px;
            height: 100px;
            border: 5px solid #bdc3c7;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 10px;
        }
        
        #scoreCardTemplate .details {
            font-size: 1.2em;
            font-weight: 600;
            margin: 5px 0;
            color: #3498db;
        }
        
        #scoreCardTemplate .slogan {
            font-size: 1.5em;
            font-weight: 700;
            color: #e74c3c; /* 紅色口號 */
            margin: 15px 0;
        }
        
        #scoreCardTemplate .qr-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 15px;
        }
        
        #scoreCardTemplate .qr-container p {
            font-size: 0.7em;
            color: #95a5a6;
            margin: 0;
        }
    </style>
</head>
<body>

    <div id="game-title">
        <h1>靈根吉吉射爆霉運</h1>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <!-- 🎯 新增 GIF 顯示元素 -->
        <!-- 請將 src 替換為您想要播放的 GIF 圖片網址 -->
        <img id="ultimateGif" 
             src="SHIVA.gif" 
             alt="Ultimate Explosion GIF" 
             style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 9; display: none; pointer-events: none;"
             onerror="this.src='https://placehold.co/800x600/000000/FFFFFF?text=Ultimate+GIF+Missing'"
        />
        <!-- ----------------------- -->

        <button id="superBombButton" class="bomb-button">
            <span id="bombCount">B</span>
        </button>

        <div id="ui-panel">
            <div class="game-info">SCR: <span id="scoreDisplay">0</span></div>
            
            <div class="game-info charge-info">
                <span id="chargeBar" class="charge-bar-wrapper">
                    <div id="chargeFill" class="charge-fill"></div>
                </span>
            </div>
            
            <div class="game-info">
                <!-- 顯示難度等級和當前炮台數量 -->
                LV: <span id="levelDisplay">1</span> (x<span id="cannonCountDisplay">1</span>)
            </div>
            <div class="game-info life-indicators-wrapper">
                <div id="livesContainer" class="life-indicators">
                    <div id="life3" class="life-dot life-green"></div>
                    <div id="life2" class="life-dot life-green"></div>
                    <div id="life1" class="life-dot life-green"></div>
                </div>
            </div>
        </div>
        
        <div id="messageBox">
            <h2 id="messageTitle"></h2>
            <div id="selection-container"></div>
            <p id="messageText"></p>
            <!-- 戰績卡下載按鈕將會被插入在這裡 -->
            <button id="startRestartButton" class="control-button">出發</button>
        </div>
    </div>
    
    <footer id="game-footer">
        靈根吉吉開運好物製販所 2025年出品
    </footer>

    <!-- 🎯 戰績卡圖片模板 - 隱藏在畫面之外，用於 html2canvas 處理 -->
    <div id="scoreCardTemplate">
        <div class="content-wrapper" style="flex-grow: 1; display: flex; flex-direction: column; align-items: center;">
            <p style="font-size: 0.8em; color: #95a5a6; margin: 0;">— 戰績報告 —</p>
            <h2 class="title">《靈根吉吉射爆霉運》</h2>

            <img id="scoreCardCannonImage" src="" alt="戰機圖形" style="margin-top: 15px;" onerror="this.src='https://placehold.co/100x100/3498db/FFFFFF?text=Cannon+Image'" />
            
            <!-- 修正 1：戰機 -> 使用 -->
            <p class="details" id="scoreCardCannonName">使用：XX靈根</p> 
            <!-- 修正 2：等級：LV.1 -> 等級：1 -->
            <p class="details" id="scoreCardLevel">等級：1</p>
            <!-- 修正 3：火力稱號，將在 JS 中動態設定 -->
            <p class="details" id="scoreCardCannonCount" style="font-size: 1em;">你是靈根吉吉挑戰者！</p>
            
            <div style="width: 100%; border-top: 2px dashed #95a5a6; margin: 15px 0;"></div>
            
            <!-- 修正 4：最終戰績 -> 消滅霉運 -->
            <p style="font-size: 1.5em; font-weight: 300; margin: 0;">消滅霉運</p>
            <div id="finalScore">0</div>
        </div>
    </div>

    <script>
        // =================================================================================
        // 圖片自定義配置區塊
        // =================================================================================
        
        // 砲台碰撞區域尺寸：70x70px
        const CANNON_COLLISION_SIZE = 70;
        // 遊戲內砲台圖片顯示尺寸：70x70px
        const CANNON_DISPLAY_SIZE = 70;
        
        // 包含可選角色和隨機選項
        const CANNONS_CONFIG = {
            'cannon1': {
                url: 'flyA.gif', // 更新為本地路徑
                name: '破魔靈根', // 更新名稱以符合戰績表格式
                image: new Image(),
                type: 'selectable',
                // --- Pomo (穿透) 特性 ---
                bulletRadius: 9, 
                fireRateMultiplier: 2.0, 
                bulletColor: '#3498db', 
                bulletDurability: 9, 
                description: '慢速重砲',
            },
            'cannon2': {
                url: 'flyB.gif', // 更新為本地路徑
                name: '正緣靈根', // 更新名稱以符合戰績表格式
                image: new Image(),
                type: 'selectable',
                // --- Zhengyuan (霰彈) 特性 ---
                bulletRadius: 2, 
                fireRateMultiplier: 1.0, 
                bulletColor: '#e74c3c', 
                bulletDurability: 1, 
                description: '中速霰彈',
            },
            'cannon3': {
                url: 'flyC.gif', // 更新為本地路徑
                name: '豐盛靈根', // 更新名稱以符合戰績表格式
                image: new Image(),
                type: 'selectable',
                // --- Fengsheng (連射) 特性 ---
                bulletRadius: 4, 
                fireRateMultiplier: 0.5, 
                bulletColor: '#f1c40f', 
                bulletDurability: 1,
                description: '快速普彈',
            },
            'random': {
                // 使用佔位符圖片或預設繪製，此處用佔位符
                url: 'https://placehold.co/70x70/3498db/FFFFFF?text=RANDOM',
                name: '隨機靈根',
                image: new Image(),
                type: 'random',
                description: '濕婆決定',
            }
        };

        let selectedCannonId = 'random'; // 預設選擇隨機
        let cannonImage = CANNONS_CONFIG[selectedCannonId].image; // 當前使用的圖片物件
        let currentCannonConfig = {}; // 存儲當前角色的配置
        const BASE_AUTO_FIRE_INTERVAL = 200; // 基礎自動射擊間隔 (毫秒)
        
        // 預載入所有圖片
        Object.values(CANNONS_CONFIG).forEach(cannon => {
            cannon.image.onload = () => { cannon.image.isLoaded = true; };
            cannon.image.onerror = () => { console.error(`圖片載入失敗: ${cannon.name}`); cannon.image.isLoaded = false; };
            cannon.image.src = cannon.url;
        });


        // =================================================================================
        // 音效配置與預載入
        // =================================================================================
        
        const SFX_PATHS = {
            LASER: 'audio/Laser.mp3', // 射擊 (基礎檔，用來變速)
            POP: 'audio/Pop.mp3', // 擊中/擊毀
            HIT: 'audio/Hit.mp3', // 角色受傷
            POWER_UP: 'audio/Power-Up.mp3', // 充能完成
            ULTIMATE_BOOM: 'audio/UltimateBoom.mp3'// 釋放大絕
        };

        const sfx = {};
        for (const key in SFX_PATHS) {
            sfx[key] = new Audio(SFX_PATHS[key]);
            sfx[key].load();
        }

        /**
         * 播放音效的通用函數，確保可以重複播放並設定參數。
         */
        function playSfx(audio, volume = 1.0, rate = 1.0) {
            if (!audio) return;
            // 使用 cloneNode 確保音效可以快速且重複播放
            const clone = audio.cloneNode(true);
            clone.volume = Math.min(1.0, Math.max(0.0, volume)); 
            clone.playbackRate = rate;
            // 嘗試播放，防止未經用戶互動被瀏覽器阻止
            clone.play().catch(e => { /* 靜默處理自動播放失敗 */ });
        }


        // =================================================================================
        // 全域常數與初始化
        // =================================================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const startRestartButton = document.getElementById('startRestartButton');
        const selectionContainer = document.getElementById('selection-container');
        const gameTitleElement = document.getElementById('game-title'); 
        const bodyElement = document.body; 
        const cannonCountDisplay = document.getElementById('cannonCountDisplay');
        const lifeDots = [
            document.getElementById('life1'),
            document.getElementById('life2'),
            document.getElementById('life3')
        ];
        
        // 🎯 大絕招系統相關 DOM 元素
        const superBombButton = document.getElementById('superBombButton');
        const bombCountDisplay = document.getElementById('bombCount');
        const chargeFill = document.getElementById('chargeFill');
        
        // 🎯 戰績卡相關 DOM 元素
        const scoreCardTemplate = document.getElementById('scoreCardTemplate');

        // 🎯 新增 GIF 元素獲取
        const ultimateGif = document.getElementById('ultimateGif'); 
        
        // 🎯 新增：炮台升級相關變數 (已更新為上限 3 個)
        const CANNON_UPGRADE_THRESHOLD_1 = 10000;
        const CANNON_UPGRADE_THRESHOLD_2 = 20000;
        const MAX_CANNON_COUNT = 3; 

        let nextCannonThreshold = CANNON_UPGRADE_THRESHOLD_1; 
        let cannonCount = 1; // 玩家擁有的炮台數量
        const CANNON_SPACING = CANNON_DISPLAY_SIZE + 10; // 炮台之間的間距
        
        // 🎯 難度隨分數增加（新的邏輯）
        const SCORE_TIER_THRESHOLD = 10000;
        const DIFFICULTY_HP_MULTIPLIER = 1.3;
        const DIFFICULTY_SCORE_MULTIPLIER = 1.3;

        let scoreTier = 0; // 0: 0-9999, 1: 10000-19999, 2: 20000-29999, etc.
        let nextScoreTierThreshold = SCORE_TIER_THRESHOLD; // 10000
        let currentHealthFactor = 1.0; // Health multiplier based on scoreTier
        let currentScoreFactor = 1.0; // Score multiplier based on scoreTier

        // 黴菌顏色配置 (已更新為八種不同顏色)
        const MOLD_COLORS = {
            'normal': '#3c6e71', // 墨綠色 (基礎)
            'lively': '#fca311', // 橙黃色 (活潑)
            'fast': '#e74c3c', // 亮紅色 (疾速)
            'dashing': '#5d5d5a', // 灰黑色 (衝刺)
            'armored': { // 裝甲黴菌 (兩種顏色)
                full: '#55a630', // 森林綠 (滿血)
                hit: '#76c893' // 淺綠 (受損)
            },
            'weaving': '#d5bdaf', // 米黃色 (編織)
            'sturdy': '#8e7a00', // 深土黃色 (堅固)
            'huge': '#7a5a8f' // 紫羅蘭色 (巨大)
        };
        const MOLD_NORMAL_RADIUS = 15;
        const MOLD_BASE_SPEED = 0.8;
        
        // 遊戲狀態變數
        let cannon = {}; // 炮台現在代表整個編隊的中心點
        let bullets = [];
        let mold = [];
        let score = 0;
        let lives = 3;
        let isGameOver = false;
        let isGameStarted = false;
        let gameLoopRunning = false;
        let lastMoldSpawnTime = 0;
        let moldSpawnInterval = 1000;
        let moldSpeed = MOLD_BASE_SPEED;
        
        // 🎯 大絕招系統狀態
        let superBombCharge = 0;
        let superBombs = 0;
        const CHARGE_THRESHOLD = 1000;
        let isSuperExploding = false;
        let superExplosionStartTime = 0; // 爆炸開始時間
        const SUPER_EXPLOSION_DURATION = 1000; // 爆炸視覺和震動持續時間 1000ms
        const SUPER_SHAKE_INTENSITY = 10; // 爆炸震動強度
        
        // 玩家輸入狀態
        let leftPressed = false;
        let rightPressed = false;

        // 自動射擊狀態
        let autoFireInterval = BASE_AUTO_FIRE_INTERVAL;
        let lastFireTime = 0;
        
        // 擊中效果狀態
        let explosions = [];

        // 傷害視覺效果狀態
        let damageEffectActive = false;
        const DAMAGE_DURATION = 300;
        let damageStartTime = 0;
        
        // 難度控制變數
        let difficultyLevel = 1;
        const DIFFICULTY_STEP_SCORE = 120;
        let nextDifficultyScore = DIFFICULTY_STEP_SCORE;
        const DIFFICULTY_FACTOR = 1.1;
        
        // 黴菌生成輪替邏輯 (已擴展至 8 種)
        let moldTypeCounter = 0;
        const MOLD_TYPES_SEQUENCE = [
            'normal', 'fast', 'lively', 'normal', 
            'armored', 'dashing', 'sturdy', 'huge', 
            'weaving', 'normal'
        ];

        // ----------------------------------------------------
        // 輔助函數: 獲取炮台位置資訊
        // ----------------------------------------------------
        /**
         * 根據當前炮台數量和編隊中心點 (cannon.x) 計算每個炮台的繪圖和中心位置。
         * @returns {Array<{drawX: number, centerX: number}>} 每個炮台的位置陣列。
         */
        function getCannonPositions() {
            const positions = [];
            const num = cannonCount;
            
            // 計算總間距 (中心點到中心點的距離)
            const totalSpacing = (num - 1) * CANNON_SPACING;
            
            // 左側第一個炮台的中心 X 座標
            const startCenterX = cannon.x - totalSpacing / 2;
            
            for (let i = 0; i < num; i++) {
                const individualCenterX = startCenterX + i * CANNON_SPACING;
                // 繪圖 X 座標是左上角 (中心 X - 圖片半寬)
                const individualDrawX = individualCenterX - cannon.imgWidth / 2;
                positions.push({
                    drawX: individualDrawX,
                    centerX: individualCenterX
                });
            }
            return positions;
        }

        // ----------------------------------------------------
        // 輔助函數: 根據等級計算背景顏色 (從深藍到白)
        // ----------------------------------------------------
        function getBackgroundColor(level) {
            const maxLevelForColor = 100;
            const progress = Math.min(1, (level - 1) / (maxLevelForColor - 1));
            // 從 #2c3e50 (44, 62, 80) 逐漸過渡到白色 (255, 255, 255)
            const r = Math.floor(44 + (255 - 44) * progress);
            const g = Math.floor(62 + (255 - 62) * progress);
            const b = Math.floor(80 + (255 - 80) * progress);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // ----------------------------------------------------
        // 輔助函數: 創建不同類型的黴菌 (包含 4 種新類型)
        // ----------------------------------------------------
        function createMold(type, baseSpeed) {
            let baseHealth = 1;

            let m = {
                x: Math.random() * (canvas.width - MOLD_NORMAL_RADIUS * 2) + MOLD_NORMAL_RADIUS,
                y: -MOLD_NORMAL_RADIUS,
                radius: MOLD_NORMAL_RADIUS,
                type: type,
                health: 1, 
                ySpeed: baseSpeed,
                hSpeed: 0,
                color: MOLD_COLORS[type] || MOLD_COLORS['normal'], 
                dashTimer: 0,
                isDashing: false,
                dashInterval: 3000 * (1 / baseSpeed),
                normalRadius: MOLD_NORMAL_RADIUS,
                isHit: false,
                hitTimer: 0,
            };

            // 1. 根據類型設定基礎屬性和顏色
            switch (type) {
                case 'huge':
                    baseHealth = 12;
                    m.maxRadius = 25;
                    m.medRadius = 20;
                    m.radius = m.maxRadius;
                    m.ySpeed = baseSpeed / 3;
                    m.color = MOLD_COLORS['huge'];
                    break;
                case 'lively':
                    m.hSpeed = 1.5 * (Math.random() > 0.5 ? 1 : -1);
                    m.color = MOLD_COLORS['lively'];
                    break;
                case 'dashing':
                    m.dashTimer = m.dashInterval + Math.random() * 1500;
                    m.color = MOLD_COLORS['dashing'];
                    break;
                case 'fast': 
                    m.ySpeed = baseSpeed * 2.0;
                    m.color = MOLD_COLORS['fast'];
                    break;
                case 'armored': 
                    baseHealth = 2;
                    m.armoredColor = MOLD_COLORS['armored'].full; 
                    m.unarmoredColor = MOLD_COLORS['armored'].hit; 
                    m.color = m.armoredColor;
                    break;
                case 'weaving': 
                    m.hSpeed = 1.0 * (Math.random() > 0.5 ? 1 : -1);
                    m.weaveTimer = 1000;
                    m.color = MOLD_COLORS['weaving'];
                    break;
                case 'sturdy': 
                    baseHealth = 6;
                    m.ySpeed = baseSpeed * 0.5;
                    m.color = MOLD_COLORS['sturdy'];
                    break;
                case 'normal':
                default:
                    m.color = MOLD_COLORS['normal'];
                    break;
            }

            // 2. 🎯 應用難度分數等級的生命值乘數，並四捨五入
            m.health = Math.round(baseHealth * currentHealthFactor);
            // 確保最低生命值為 1
            if (m.health < 1) m.health = 1; 
            m.initialHealth = m.health; // 紀錄初始血量以便計算血條

            // 3. 調整 Armored 類型，以應用新的 health 值
            if (m.type === 'armored') {
                // 裝甲顏色在血量大於 50% 時顯示，否則顯示受損顏色
                m.armoredThreshold = Math.ceil(m.health / 2); 
            }

            return m;
        }
        
        // 確保畫布尺寸適應容器
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            
            // 🎯 獲取由 CSS 設置的客戶端尺寸
            const clientWidth = container.clientWidth;
            const canvasElement = document.getElementById('gameCanvas');
            const clientHeight = canvasElement.clientHeight;

            // 設置畫布的繪圖尺寸
            canvasElement.width = clientWidth;
            canvasElement.height = clientHeight;

            // 調整砲台位置
            // 🎯 這裡將 cannon.x 定義為炮台編隊的中心 X 座標
            if (cannon.x === undefined) {
                cannon.width = CANNON_COLLISION_SIZE;
                cannon.height = CANNON_COLLISION_SIZE;
                cannon.imgWidth = CANNON_DISPLAY_SIZE;
                cannon.imgHeight = CANNON_DISPLAY_SIZE;
                cannon.x = canvasElement.width / 2; // 中心 X 座標
                cannon.y = canvasElement.height - CANNON_COLLISION_SIZE - 10;
                cannon.speed = 6;
            } else {
                // 重新計算中心點，並將其限制在邊界內
                const spacing = CANNON_SPACING;
                const formationWidth = (cannonCount - 1) * spacing + cannon.imgWidth;
                const halfFormationWidth = formationWidth / 2;

                cannon.x = Math.max(halfFormationWidth, Math.min(canvasElement.width - halfFormationWidth, cannon.x));
                cannon.y = canvasElement.height - CANNON_COLLISION_SIZE - 10;
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // ----------------------------------------------------
        // 介面更新
        // ----------------------------------------------------

        function updateLivesDisplay() {
            playSfx(sfx.HIT, 0.8, 1.0); // 播放受傷音效

            lifeDots.forEach((dot, index) => {
                dot.className = 'life-dot'; // 重置樣式
                if (index < lives) {
                    // 根據生命值設置顏色
                    if (lives === 3) dot.classList.add('life-green');
                    else if (lives === 2) dot.classList.add('life-yellow');
                    else dot.classList.add('life-red');
                } else {
                    dot.classList.add('life-grey'); // 失去的生命值顯示灰色
                }
            });
        }
        
        function updateChargeDisplay() {
            const ratio = superBombs === 0 ? superBombCharge / CHARGE_THRESHOLD : 1; // 充滿時顯示 100%
            chargeFill.style.width = `${ratio * 100}%`;

            if (superBombs > 0) {
                superBombButton.classList.add('ready');
                bombCountDisplay.textContent = 'B'; 
            } else {
                superBombButton.classList.remove('ready');
                bombCountDisplay.textContent = '0';
            }
        }
        
        function updateScore(points) {
            const previousSuperBombs = superBombs;
            
            score += points;
            scoreDisplay.textContent = score;

            // 🎯 炮台升級檢查 (限制為 3 個)
            if (cannonCount < MAX_CANNON_COUNT) {
                if (cannonCount === 1 && score >= CANNON_UPGRADE_THRESHOLD_1) {
                    cannonCount++;
                    nextCannonThreshold = CANNON_UPGRADE_THRESHOLD_2; // 下一個閾值到 20000
                    playSfx(sfx.POWER_UP, 1.0, 1.0);
                    cannonCountDisplay.textContent = cannonCount;
                    console.log(`恭喜！靈根升級！目前擁有 ${cannonCount} 個炮台！`);
                    resizeCanvas();
                } else if (cannonCount === 2 && score >= CANNON_UPGRADE_THRESHOLD_2) {
                    cannonCount++;
                    nextCannonThreshold = Infinity; // 達到上限，不再升級
                    playSfx(sfx.POWER_UP, 1.0, 1.0);
                    cannonCountDisplay.textContent = cannonCount;
                    console.log(`恭喜！靈根升級！目前擁有 ${cannonCount} 個炮台！`);
                    resizeCanvas();
                }
            }
            
            // 🎯 難度分數等級檢查 (每 10000 分，增加 HP/分數)
            while (score >= nextScoreTierThreshold) {
                scoreTier++;
                nextScoreTierThreshold += SCORE_TIER_THRESHOLD;
                
                // 增加生命值和分數乘數
                currentHealthFactor = Math.pow(DIFFICULTY_HP_MULTIPLIER, scoreTier);
                currentScoreFactor = Math.pow(DIFFICULTY_SCORE_MULTIPLIER, scoreTier);
                console.log(`分數等級提升到 ${scoreTier}。HP倍率: ${currentHealthFactor.toFixed(2)}, 分數倍率: ${currentScoreFactor.toFixed(2)}`);
            }

            // 🎯 續能邏輯：只有當前沒有大炸彈時才累積點數
            if (superBombs < 1) {
                superBombCharge += points;
                if (superBombCharge >= CHARGE_THRESHOLD) {
                    superBombs = 1;
                    superBombCharge = CHARGE_THRESHOLD; // 充滿後鎖定在門檻值
                }
            }
            
            // 播放充能完成音效
            if (superBombs > previousSuperBombs) {
                 playSfx(sfx.POWER_UP, 1.0, 1.0); 
            }
            
            updateChargeDisplay();

            // 檢查是否升級 (難度等級 - 控制黴菌速度/生成頻率)
            if (score >= nextDifficultyScore) {
                difficultyLevel++;
                levelDisplay.textContent = difficultyLevel;
                // 加速黴菌生成和移動速度
                moldSpawnInterval = Math.max(200, moldSpawnInterval * 0.9); // 最小間隔 200ms
                moldSpeed = MOLD_BASE_SPEED * Math.pow(DIFFICULTY_FACTOR, difficultyLevel - 1);
                
                // 調整下一級所需分數
                nextDifficultyScore = Math.ceil(nextDifficultyScore * 1.5);
            }
        }

        // ----------------------------------------------------
        // 遊戲流程控制
        // ----------------------------------------------------
        
        function selectRandomCannon() {
            const selectableIds = Object.keys(CANNONS_CONFIG).filter(id => CANNONS_CONFIG[id].type === 'selectable');
            const randomId = selectableIds[Math.floor(Math.random() * selectableIds.length)];
            return randomId;
        }

        function startGame() {
            // 1. 處理隨機選擇
            let finalCannonId = selectedCannonId;
            if (finalCannonId === 'random') {
                finalCannonId = selectRandomCannon();
            }
            
            // 2. 應用角色配置
            currentCannonConfig = CANNONS_CONFIG[finalCannonId];
            cannonImage = currentCannonConfig.image;
            if (!cannonImage.isLoaded) {
                 console.warn(`Warning: Cannon image for ${currentCannonConfig.name} is not loaded.`);
            }

            autoFireInterval = BASE_AUTO_FIRE_INTERVAL * currentCannonConfig.fireRateMultiplier;
            
            // 3. 嘗試播放一次聲音以解鎖瀏覽器音訊
            playSfx(sfx.LASER, 0.0);
            
            // 4. 初始化遊戲狀態
            initGame();
            
            isGameStarted = true;
            messageBox.style.display = 'none';

            // 隱藏標題，將 body 頂部對齊，最大化遊戲畫布空間
            gameTitleElement.style.display = 'none';
            bodyElement.classList.add('game-active');
            
            // 重新調整尺寸以適應標題隱藏後的空間變化
            resizeCanvas();

            if (!gameLoopRunning) {
                gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function showGameOver(title, message) {
            isGameOver = true;
            gameLoopRunning = false;
            
            messageTitle.textContent = title;
            messageText.innerHTML = `${message}<br>${score} 個霉運！`; // Final Score message adjusted
            selectionContainer.innerHTML = ''; // 清除選擇介面
            
            // 移除舊的按鈕 (除了 startRestartButton)
            let oldDownloadButton = document.getElementById('downloadScoreCardButton');
            if (oldDownloadButton) oldDownloadButton.remove();
            
            // 創建並插入下載按鈕
            const downloadButton = document.createElement('button');
            downloadButton.id = 'downloadScoreCardButton';
            downloadButton.className = 'control-button secondary';
            downloadButton.textContent = '下載戰績卡 (PNG)';
            downloadButton.addEventListener('click', downloadScoreCard);
            messageBox.insertBefore(downloadButton, startRestartButton);

            startRestartButton.textContent = '重新開始'; // Restart button
            
            // 準備戰績卡數據
            prepareScoreCard(score, difficultyLevel, currentCannonConfig, cannonCount);
            
            messageBox.style.display = 'flex';
            
            // 顯示標題，將 body 內容居中
            gameTitleElement.style.display = 'block';
            bodyElement.classList.remove('game-active');
        }
        
        // ----------------------------------------------------
        // 🎯 戰績卡下載邏輯
        // ----------------------------------------------------
        function prepareScoreCard(finalScore, finalLevel, cannonConfig, finalCannonCount) {
             // 確保戰績卡可見 (但仍移出視窗外，因為 html2canvas 必須在 DOM 中找到元素)
            scoreCardTemplate.style.position = 'absolute';
            scoreCardTemplate.style.left = '-9999px';
            scoreCardTemplate.style.zIndex = '100'; // 確保在頂層，儘管在屏幕外
            
            // 1. 設置最終分數
            document.getElementById('finalScore').textContent = finalScore;
            
            // 2. 修正稱謂：戰機 -> 使用
            document.getElementById('scoreCardCannonName').textContent = `${cannonConfig.name}`;
            
            // 3. 修正等級顯示：移除 LV.
            document.getElementById('scoreCardLevel').textContent = `LV.${finalLevel}`;
            
            // 4. 修正火力稱號
            let firepowerTitle;
            switch (finalCannonCount) {
                case 1:
                    firepowerTitle = "您是靈根吉吉學徒！";
                    break;
                case 2:
                    firepowerTitle = "您是靈根吉吉專家！";
                    break;
                case 3:
                    firepowerTitle = "您是靈根吉吉大師！";
                    break;
                default:
                    firepowerTitle = `火力：x${finalCannonCount} 靈根`; // Fallback
            }
            document.getElementById('scoreCardCannonCount').textContent = firepowerTitle;

            // 5. 設置圖片
            document.getElementById('scoreCardCannonImage').src = cannonConfig.url;
            document.getElementById('scoreCardCannonImage').alt = cannonConfig.name;
        }

        function downloadScoreCard() {
            const downloadButton = document.getElementById('downloadScoreCardButton');
            downloadButton.disabled = true;
            downloadButton.textContent = '正在生成...';

            // 調整模板以確保所有內容都能正確渲染 (雖然已經是固定尺寸，但還是確保其尺寸)
            scoreCardTemplate.style.width = '400px'; 
            scoreCardTemplate.style.height = '600px';

            html2canvas(scoreCardTemplate, {
                // 必須設定滾動位置，因為模板被移到螢幕外了
                scrollX: 0,
                scrollY: 0,
                // 設定精確的寬高以確保圖片尺寸一致
                width: 400,
                height: 600,
                scale: 2 // 提高解析度以獲得更清晰的圖片 (800x1200)
            }).then(canvas => {
                downloadButton.textContent = '下載完成！';
                downloadButton.disabled = false;
                
                // 創建下載連結
                const link = document.createElement('a');
                link.download = `靈根吉吉戰績_${score}.png`;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 重設按鈕文字
                setTimeout(() => {
                    downloadButton.textContent = '下載戰績卡 (PNG)';
                }, 2000);
            }).catch(error => {
                console.error("生成戰績卡時發生錯誤:", error);
                downloadButton.textContent = '生成失敗！';
                downloadButton.disabled = false;
            });
        }
        // ----------------------------------------------------
        // 大絕招邏輯
        // ----------------------------------------------------

         function fireSuperBomb() {
            if (superBombs < 1 || isGameOver) return;
            
            playSfx(sfx.ULTIMATE_BOOM, 1.0, 1.0); // 播放大絕音效

            // 1. 清空所有黴菌和子彈
            const moldsCleared = mold.length;
            mold = [];
            bullets = [];
            
            // 2. 應用分數獎勵
            // 每個清除的黴菌給予 20 額外分數
            const bonusScore = moldsCleared * 20; 
            updateScore(bonusScore); 

            // 3. 觸發超大爆炸視覺和震動效果
            isSuperExploding = true;
            superExplosionStartTime = performance.now(); // 記錄開始時間
            
            // 🎯 在這裡加入 GIF 顯示邏輯
            ultimateGif.style.display = 'block';
            // 透過重設 src 強制 GIF 從頭播放
            const gifSrc = ultimateGif.src; 
            ultimateGif.src = '';
            ultimateGif.src = gifSrc;
            // ---------------------------------
            
            // 4. 重置狀態
            superBombs = 0;
            superBombCharge = 0;
            updateChargeDisplay();
        }

        // ----------------------------------------------------
        // 遊戲輸入處理
        // ----------------------------------------------------

        function handleInput() {
            if (isGameStarted && !isGameOver) {
                const step = cannon.speed;
                const formationWidth = (cannonCount - 1) * CANNON_SPACING + cannon.imgWidth;
                const halfFormationWidth = formationWidth / 2;
                
                // 🎯 cannon.x 代表編隊的中心 X 座標

                if (leftPressed) {
                    const newCenterX = cannon.x - step;
                    // 檢查左邊界 (中心 - 半寬 >= 0)
                    if (newCenterX - halfFormationWidth >= 0) {
                        cannon.x = newCenterX;
                    } else {
                        cannon.x = halfFormationWidth; // 貼齊左邊
                    }
                }
                if (rightPressed) {
                    const newCenterX = cannon.x + step;
                    // 檢查右邊界 (中心 + 半寬 <= canvas.width)
                    if (newCenterX + halfFormationWidth <= canvas.width) {
                        cannon.x = newCenterX;
                    } else {
                        cannon.x = canvas.width - halfFormationWidth; // 貼齊右邊
                    }
                }
            }
        }
        
        function handleCanvasControl(e) {
            if (messageBox.style.display !== 'none' || !isGameStarted || isGameOver) return;
            
            let clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
            if (e.touches) e.preventDefault(); // 阻止移動端預設行為
            
            const rect = canvas.getBoundingClientRect();
            const touchX = clientX - rect.left; 
            
            // 根據點擊位置決定移動方向
            const centerX = cannon.x;
            if (touchX < centerX) {
                leftPressed = true;
                rightPressed = false;
            } else {
                rightPressed = true;
                leftPressed = false;
            }
        }
        
        function stopMovement() {
            leftPressed = false;
            rightPressed = false;
        }

        // 註冊畫布事件監聽器
        canvas.addEventListener('mousedown', handleCanvasControl);
        canvas.addEventListener('touchstart', handleCanvasControl, { passive: false }); 
        canvas.addEventListener('mouseup', stopMovement);
        canvas.addEventListener('touchend', stopMovement);
        canvas.addEventListener('mouseleave', stopMovement); 
        
        // 註冊大絕招按鈕事件
        superBombButton.addEventListener('click', fireSuperBomb);
        
        // 鍵盤事件
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = true;
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = true;
            } else if ((e.key === ' ' || e.key === 'Enter') && superBombs > 0) {
                fireSuperBomb();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                leftPressed = false;
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                rightPressed = false;
            }
        });

        // 開始/重新開始按鈕事件
        startRestartButton.addEventListener('click', () => {
            if (isGameStarted && isGameOver) {
                initGame();
                showCharacterSelection();
            } else if (!isGameStarted) {
                startGame();
            }
        });

        // ----------------------------------------------------
        // 射擊、更新、碰撞邏輯 
        // ----------------------------------------------------
        
        function getCannonShotRate(cannonName) {
            if (cannonName.includes('破魔')) return 0.8; 
            if (cannonName.includes('豐盛')) return 1.2;
            return 1.0; 
        }

        function fireBullet() {
            const { bulletRadius, bulletColor, bulletDurability, name } = currentCannonConfig;
            
            // 播放射擊音效，並根據機體類型調整播放速率
            playSfx(sfx.LASER, 0.5, getCannonShotRate(name));

            const cannonPositions = getCannonPositions();

            // 🎯 針對每一個炮台位置發射子彈
            cannonPositions.forEach(pos => {
                const bulletX = pos.centerX;

                if (name.includes('破魔')) {
                    bullets.push({
                        x: bulletX,
                        y: cannon.y,
                        radius: bulletRadius,
                        color: bulletColor,
                        durability: bulletDurability,
                        type: 'pomo', 
                        hSpeed: 0
                    });
                } else if (name.includes('正緣')) {
                    for (let i = -1; i <= 1; i++) {
                        bullets.push({
                            x: bulletX + i * 5, 
                            y: cannon.y,
                            radius: bulletRadius,
                            color: bulletColor,
                            durability: 1, 
                            type: 'zhengyuan',
                            hSpeed: i * 0.5
                        });
                    }
                } else {
                    bullets.push({
                        x: bulletX,
                        y: cannon.y,
                        radius: bulletRadius,
                        color: bulletColor,
                        durability: 1,
                        type: 'normal',
                        hSpeed: 0
                    });
                }
            });
        }

        function updateGame(deltaTime) {
            const now = performance.now();

            handleInput();

            if (now - lastFireTime > autoFireInterval) {
                fireBullet();
                lastFireTime = now;
            }

            bullets = bullets.filter(bullet => {
                bullet.y -= 8;
                bullet.x += bullet.hSpeed || 0;
                return bullet.y + bullet.radius > 0;
            });

            updateMolds(deltaTime, now);
            
            if (now - lastMoldSpawnTime > moldSpawnInterval) {
                const type = MOLD_TYPES_SEQUENCE[moldTypeCounter % MOLD_TYPES_SEQUENCE.length];
                mold.push(createMold(type, moldSpeed));
                moldTypeCounter++;
                lastMoldSpawnTime = now;
            }
            
            checkCollisions(deltaTime);
            updateExplosions(deltaTime);

            if (lives <= 0) {
                showGameOver('靈根能量用罄', '恭喜您，已經淨化了');
            }
        }
        
        function updateMolds(deltaTime, now) {
            // 🎯 計算當前炮台編隊的邊界
            const formationWidth = (cannonCount - 1) * CANNON_SPACING + cannon.imgWidth;
            const halfFormationWidth = formationWidth / 2;

            const formationX_left = cannon.x - halfFormationWidth; 
            const formationX_right = cannon.x + halfFormationWidth; 

            mold = mold.filter(m => {
                m.y += m.ySpeed;

                if (m.type === 'lively') {
                    m.x += m.hSpeed;
                    if (m.x - m.radius < 0 || m.x + m.radius > canvas.width) m.hSpeed *= -1;
                } else if (m.type === 'weaving') {
                    if (now - m.weaveTimer > 1000) {
                        m.hSpeed *= -1;
                        m.weaveTimer = now;
                    }
                    m.x += m.hSpeed;
                    if (m.x - m.radius < 0) { m.x = m.radius; m.hSpeed = Math.abs(m.hSpeed); }
                    if (m.x + m.radius > canvas.width) { m.x = canvas.width - m.radius; m.hSpeed = -Math.abs(m.hSpeed); }
                } else if (m.type === 'dashing') {
                    m.dashTimer -= deltaTime;
                    if (m.dashTimer < 0 && !m.isDashing) {
                        m.isDashing = true;
                        m.dashTimer = 500; 
                    }
                    if (m.isDashing) {
                        m.y += m.ySpeed * 5; 
                        m.dashTimer -= deltaTime;
                        if (m.dashTimer <= 0) {
                            m.isDashing = false;
                            m.dashTimer = m.dashInterval + Math.random() * 1500;
                        }
                    }
                }

                if (m.isHit) {
                    m.hitTimer -= deltaTime;
                    if (m.hitTimer <= 0) m.isHit = false;
                }

                if (m.y - m.radius > canvas.height) return false; 

                // 🎯 碰撞檢測 - 角色 (檢查與整個編隊的矩形碰撞)
                if (
                    m.y + m.radius >= cannon.y && m.y - m.radius <= cannon.y + cannon.height &&
                    m.x + m.radius >= formationX_left && m.x - m.radius <= formationX_right
                ) {
                    lives--;
                    updateLivesDisplay();
                    triggerDamageEffect(now);
                    createExplosion(m.x, m.y, m.radius, m.color);
                    return false; 
                }

                return true;
            });
        }
        
        function checkCollisions(deltaTime) {
            const nextBullets = [];
            const moldsToKeep = [];

            mold.forEach(m => {
                let moldHitThisFrame = false; // 用於避免重複播放擊中音效

                bullets.forEach(b => {
                    const dx = b.x - m.x;
                    const dy = b.y - m.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < b.radius + m.radius) {
                        
                        let damage = (b.type === 'pomo' && m.type === 'huge') ? 3 : 1;
                        const healthBeforeHit = m.health;
                        
                        m.health -= damage;
                        m.isHit = true;
                        m.hitTimer = 100;
                        moldHitThisFrame = true; // 標記被擊中

                        // 🎯 裝甲黴菌顏色變化
                        if (m.type === 'armored' && m.health < healthBeforeHit && m.health <= m.armoredThreshold) {
                             m.color = m.unarmoredColor; // 血量低於門檻時改變顏色
                        }
                        
                        // 🎯 巨大黴菌尺寸變化 (使用 initialHealth 確保比例穩定)
                        if (m.type === 'huge') {
                            const healthRatio = m.health / m.initialHealth;
                            if (healthRatio <= 1/3 && m.radius > m.normalRadius) m.radius = m.normalRadius;
                            else if (healthRatio <= 2/3 && m.radius > m.medRadius) m.radius = m.medRadius;
                        }
                        
                        if (m.health <= 0) {
                            // 擊毀音效 (Pop.mp3, 正常播放)
                            playSfx(sfx.POP, 0.7, 1.0); 
                            
                            let basePoints = 10;
                            switch (m.type) {
                                case 'fast': basePoints = 25; break;
                                case 'armored': basePoints = 30; break;
                                case 'weaving': basePoints = 35; break;
                                case 'sturdy': basePoints = 40; break;
                                case 'huge': basePoints = 50; break;
                                case 'lively': basePoints = 20; break;
                                case 'dashing': basePoints = 30; break;
                                default: basePoints = 10; break;
                            }
                            
                            // 🎯 應用難度分數等級的分數乘數，並四捨五入
                            const points = Math.round(basePoints * currentScoreFactor);

                            updateScore(points);
                            createExplosion(m.x, m.y, m.radius, m.color);
                        } else if (healthBeforeHit > 0) {
                            // 擊中音效 (Pop.mp3, 快速高音)
                            playSfx(sfx.POP, 0.3, 1.5); 
                        }

                        b.durability--;
                    }
                });

                if (m.health > 0) moldsToKeep.push(m);
            });
            
            bullets.forEach(b => {
                if (b.durability > 0) nextBullets.push(b);
            });

            mold = moldsToKeep;
            bullets = nextBullets;
        }

        // ----------------------------------------------------
        // 視覺特效處理
        // ----------------------------------------------------
        
        function createExplosion(x, y, radius, color) {
            explosions.push({
                x: x,
                y: y,
                radius: radius,
                color: color,
                maxRadius: radius * 3,
                alpha: 1.0,
                speed: 10
            });
        }

        function updateExplosions(deltaTime) {
            explosions = explosions.filter(exp => {
                exp.radius += exp.speed * (deltaTime / 16.67);
                exp.alpha -= 0.05 * (deltaTime / 16.67);
                return exp.alpha > 0;
            });
        }
        
        function triggerDamageEffect(now) {
            damageEffectActive = true;
            damageStartTime = now;
        }

        function getShakeOffset(now) {
            let shakeOffset = 0;
            
            // 1. 傷害震動
            if (damageEffectActive) {
                const elapsed = now - damageStartTime;
                if (elapsed < DAMAGE_DURATION) {
                    shakeOffset = 5 * (1 - elapsed / DAMAGE_DURATION);
                } else {
                    damageEffectActive = false;
                }
            }
            
            // 2. 爆炸震動 (覆蓋傷害震動)
            if (isSuperExploding) {
                const elapsed = now - superExplosionStartTime;
                if (elapsed < SUPER_EXPLOSION_DURATION) {
                    const progress = elapsed / SUPER_EXPLOSION_DURATION;
                    // 從最大強度遞減
                    shakeOffset = SUPER_SHAKE_INTENSITY * (1 - progress); 
                } else {
                    isSuperExploding = false; // 震動結束
                    ultimateGif.style.display = 'none'; // 🎯 爆炸結束時隱藏 GIF
                }
            }

            return shakeOffset;
        }
        
        // ----------------------------------------------------
        // 繪圖邏輯
        // ----------------------------------------------------

        function drawGame() {
            if (!gameLoopRunning && !isGameStarted) return;
            
            const now = performance.now();

            ctx.fillStyle = getBackgroundColor(difficultyLevel);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 應用畫面震動效果
            const currentShakeOffset = getShakeOffset(now);
            const dx = currentShakeOffset > 0 ? Math.sin(now * 0.5) * currentShakeOffset : 0;
            const dy = currentShakeOffset > 0 ? Math.cos(now * 0.5) * currentShakeOffset : 0;
            ctx.save();
            ctx.translate(dx, dy);

            // 1. 繪製黴菌
            mold.forEach(m => {
                if (m.isHit && Math.floor(m.hitTimer / 50) % 2 === 0) {
                    ctx.fillStyle = '#ecf0f1';
                } else {
                    ctx.fillStyle = m.color;
                }
                
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();
                
                if (m.type === 'dashing' && !m.isDashing && m.dashTimer < 1000 && m.dashTimer > 0) {
                    const alpha = (1000 - m.dashTimer) / 1000 * 0.5;
                    ctx.fillStyle = `rgba(231, 76, 60, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, m.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 🎯 繪製血條 (使用 initialHealth)
                if (m.initialHealth > 1) {
                    const healthRatio = m.health / m.initialHealth;
                    const barWidth = m.radius * 2;
                    const barHeight = 4;
                    const barX = m.x - m.radius;
                    const barY = m.y - m.radius - 8;
                    
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = healthRatio > 0.5 ? '#2ecc71' : (healthRatio > 0.25 ? '#f1c40f' : '#e74c3c');
                    ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
                }
            });

            // 2. 繪製子彈
            bullets.forEach(b => {
                if (b.type === 'pomo') {
                    const durabilityRatio = b.durability / currentCannonConfig.bulletDurability;
                    ctx.fillStyle = `rgba(52, 152, 219, ${0.4 + durabilityRatio * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = '8px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(b.durability, b.x, b.y);
                } else {
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // 3. 繪製爆炸效果
            explosions.forEach(exp => {
                ctx.fillStyle = exp.color;
                ctx.globalAlpha = exp.alpha;
                ctx.beginPath();
                ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });

            // 4. 🎯 繪製炮台編隊
            const cannonPositions = getCannonPositions();
            cannonPositions.forEach(pos => {
                if (cannonImage.isLoaded) {
                    ctx.drawImage(
                        cannonImage,
                        pos.drawX, // 使用新的繪圖 X 座標
                        cannon.y,
                        cannon.imgWidth,
                        cannon.imgHeight
                    );
                } else {
                    // Fallback: 繪製方塊
                    ctx.fillStyle = 'red';
                    ctx.fillRect(pos.drawX, cannon.y, cannon.width, cannon.height);
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(currentCannonConfig.name.replace('靈根', ''), pos.centerX, cannon.y + cannon.height / 2);
                }
            });
            
            // 恢復畫布狀態
            ctx.restore();
            
            // 5. 繪製超級爆炸效果
            if (isSuperExploding) {
                const elapsed = now - superExplosionStartTime;
                const progress = elapsed / SUPER_EXPLOSION_DURATION;
                
                let radius = canvas.width * 0.8 * progress; 
                let alpha = 1.0 - progress;

                ctx.globalAlpha = Math.max(0, alpha * 0.9);
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // ----------------------------------------------------
        // 遊戲主循環
        // ----------------------------------------------------
        let lastTime = 0;

        function gameLoop(currentTime) {
            if (!gameLoopRunning) return;

            const deltaTime = Math.min(currentTime - lastTime, 100); 
            lastTime = currentTime;
            
            if (!isGameOver) {
                updateGame(deltaTime);
            }
            drawGame();

            requestAnimationFrame(gameLoop);
        }

        // ----------------------------------------------------
        // 啟動點
        // ----------------------------------------------------

        // 確保在所有 DOM 元素載入後顯示選擇畫面
        window.onload = function() {
            resizeCanvas(); 
            initGame();
            showCharacterSelection();
        };

        // ----------------------------------------------------
        // 角色選擇與畫面顯示
        // ----------------------------------------------------

        function showCharacterSelection() {
            selectionContainer.innerHTML = '';
            messageTitle.textContent = '選擇您的靈根';
            startRestartButton.textContent = '出發'; 
            
            // 移除可能存在的下載按鈕
            let oldDownloadButton = document.getElementById('downloadScoreCardButton');
            if (oldDownloadButton) oldDownloadButton.remove();
            
            messageText.textContent = CANNONS_CONFIG[selectedCannonId].description || '';

            Object.keys(CANNONS_CONFIG).forEach(id => {
                const cannon = CANNONS_CONFIG[id];
                const card = document.createElement('div');
                card.id = `card-${id}`;
                card.className = 'cannon-card';
                
                const img = document.createElement('img');
                img.src = cannon.url;
                img.width = CANNON_COLLISION_SIZE;
                img.height = CANNON_COLLISION_SIZE;

                const nameLabel = document.createElement('p');
                nameLabel.textContent = cannon.name.replace('靈根', ''); // 選擇畫面只顯示名稱

                card.appendChild(img);
                card.appendChild(nameLabel);
                selectionContainer.appendChild(card);

                card.addEventListener('click', () => selectCannon(id));
            });
            
            selectCannon(selectedCannonId);
            messageBox.style.display = 'flex';
        }

        function selectCannon(id) {
            selectedCannonId = id;
            document.querySelectorAll('.cannon-card').forEach(card => {
                card.classList.remove('selected');
                if (card.id === `card-${id}`) {
                    card.classList.add('selected');
                }
            });
            const selectedConfig = CANNONS_CONFIG[id];
            messageText.textContent = selectedConfig.description;
        }

        function initGame() {
            score = 0;
            lives = 3;
            isGameOver = false;
            isGameStarted = false;
            bullets = [];
            mold = [];
            explosions = [];
            
            difficultyLevel = 1;
            nextDifficultyScore = DIFFICULTY_STEP_SCORE;
            moldSpeed = MOLD_BASE_SPEED;
            moldSpawnInterval = 1000;
            
            superBombCharge = 0;
            superBombs = 0;
            isSuperExploding = false;

            // 🎯 靈根升級狀態初始化
            cannonCount = 1;
            nextCannonThreshold = CANNON_UPGRADE_THRESHOLD_1;
            
            // 🎯 難度隨分數增加狀態初始化
            scoreTier = 0;
            nextScoreTierThreshold = SCORE_TIER_THRESHOLD;
            currentHealthFactor = 1.0;
            currentScoreFactor = 1.0; 

            gameTitleElement.style.display = 'block';
            bodyElement.classList.remove('game-active');

            // 🎯 重新定義 cannon.x 為編隊的中心點
            cannon.width = CANNON_COLLISION_SIZE;
            cannon.height = CANNON_COLLISION_SIZE;
            cannon.imgWidth = CANNON_DISPLAY_SIZE;
            cannon.imgHeight = CANNON_DISPLAY_SIZE;
            cannon.x = canvas.width / 2; // 中心 X 座標
            cannon.y = canvas.height - CANNON_COLLISION_SIZE - 10;
            cannon.speed = 6;
            
            scoreDisplay.textContent = score;
            levelDisplay.textContent = difficultyLevel;
            cannonCountDisplay.textContent = cannonCount;

            updateLivesDisplay();
            updateChargeDisplay();
            
            requestAnimationFrame(drawGame);
        }
    </script>
</body>
</html>
